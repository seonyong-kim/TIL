# 4. The Processor
## ALU Control
- Load/Store -> add
- Branch -> subtract
- T-type -> funct field에 따라 결정<br>

## The Main Control Unit
- opcode에서 파생된 2비트를 ALUOp로 한다
- Combinational logic은 ALU 제어를 파생<br>
![image](https://github.com/user-attachments/assets/7a624270-e584-40c1-a1a6-959be95753ef)
<br> R타입의 경우 뒤에 추가적인 decoding을 한다.

## The Main Control Unit
- Control signals은 instruction에서 파생 <br>
![image](https://github.com/user-attachments/assets/cf55f87f-a345-4a97-8325-22bbd103ca06)

## Datapath with Control
![image](https://github.com/user-attachments/assets/445883ae-e24c-46d9-a49c-af8a5b427997) <br>
|종류|R-type|lw|sw|branch|
|---|---|---|---|---|
|RegDst|1|0|X|X|
|ALUSrc|0|1|1|0|
|MemtoReg|0|1|0|X|
|RegWrite|1|1|0|0|
|MemRead|0|1|0|0|
|MemWrite|0|0|1|0|
|Branch|0|0|0|1|
|ALUOp|10|00|??|01| <br>
- RegDst: 결과를 저장할 register(rd면 1 / rt면 0)
- ALUSRC: 0이면 register 사용, 1이면 즉시값
- pcsrc: beq && ALU 결과 조건 만족시: 1 / 나머지는 0

## Implementing Jumps
![image](https://github.com/user-attachments/assets/d780aff1-fa68-4224-82d0-015679f9b109) <br>
4-bit(이전 PC 상위 4bit) 26bit(jump address값) 2bit(00 고정)해서 32 bit
- Jump는 word address
- opcode에서 추가 control signal decoded가 필요하다

## Datapath with Jumps Added
![image](https://github.com/user-attachments/assets/cbacedf4-dda3-4e7f-a5af-5c38d38ec643)<br>

## Performance Issues
- 가장 긴 delay가 clock period를 결정
  - critical path는 load instruction
  - 과정은 instruction memory -> register file → ALU → data memory → register file
- 설계 원칙 위반
  - 일반적인 사례를 빠르게 처리 -> Load에 맞추면 비효율적이다.
- 파이프라이닝을 통해 성능을 향상시킬 수 있다.

## MIPS Pipeline
- Five stages, one step per stage
  - IF: memory에서 instruction 가져오기
  - ID: Instruction 해석 & register 읽기
  - EX: 산술연산 or 주소계산(ALU)
  - MEM: memory에 읽기/쓰기
  - WB: register에 결과물 작성
 
## Pipeline Performance
- 제일긴게 Cycle로 설정 -> 손해보는게 생긴다.
5각단계마다 걸리는 시간이 달라서 pipelined인지에 따라 달라진다.<br>
![image](https://github.com/user-attachments/assets/b6637734-0cb8-4f99-8b34-2ea313448eb8)

## Pipeline Speedup
- 모든 단계가 균형 잡혀 있다면 (즉, 각 단계가 같은 시간 소요) <br>
  ![image](https://github.com/user-attachments/assets/1cb0e023-df2e-4fff-bba6-639ac170ada4)
- 균형이 맞지 않으면 속도 향상은 줄어듦
- 속도 향상은 처리량 증가 덕분
  - Latency(각 명령어가 끝날 때까지 걸리는 시간)은 줄어들지 않는다.

## Pipelining and ISA Design
- MIPS ISA는 파이프라이닝을 고려해서 설계됨
  - 모든 instructions는 32-bits: one cycle에 가져오고 해석하기 쉬움
  - instruction formats이 적고 규칙적: one step에 명령어 해석과 레지스터 읽기를 처리 가능
  - Load/store addressing: 3단계에서 주소 계산, 4단계에서 메모리 접근
  - memory operands 정렬: 메모리 접근이 한 사이클이면 충분함(memory에 1번만 접근 가능)
 
## Hazards
다음 cycle에 다음 instruction를 시작하지 못하게 만드는 상황들
- Structure hazards(구조적 위험): resource 충돌
- Data hazard(데이터 위험): 이전 instruction의 data 읽기/쓰기를 끝낼 때까지 기다려야 한다
- Control hazard(제어 위험): branch경우 ALU를 해야 다음에 어떻게 할지 나온다.

## Structural Hazards
파이프라인에서 두 명령어가 같은 자원을 사용할 때 발생하는 문제
- MIPS 파이프라인에서 하나의 메모리만 사용하는 경우:
  - load/store 명령어는 데이터 접근이 필요함
  - 동시에 instruction을 가져올 수 없어서 대기해야 함 → 이로 인해 파이프라인에 bubble이 생김
  - 그래서 파이프라인 구조에서는 instruction/data memories를 분리 or instruction/data caches를 따로 사용
 
## Data Hazards
한 instruction이 이전 instruction의 데이터 접근이 완료되기를 기다려야 하는 상황이다. <be>
데이터가 준비 안되어 있는데 register dependency가 있을때 <br>

![image](https://github.com/user-attachments/assets/a6b10ba8-4338-4046-bb9a-1f06ea877000)

## Forwarding (aka Bypassing)
datapath에 추가 연결을 통해 결과가 계산되면 즉시 사용 <br>
![image](https://github.com/user-attachments/assets/d4123fe1-2c41-4bf4-a224-70e34881040b)

## Load-Use Data Hazard
필요한 시점에 값이 아직 계산되지 않았다면 시간을 거슬러 forward 할 수 없다. <br>
![image](https://github.com/user-attachments/assets/764bf9f2-c816-4251-8c69-f87298da5208)

## Code Scheduling to Avoid Stalls
서로 상관없는 instruction이 다음에 오도록 하려고 코드 순서를 재정렬할 수 있다. <br>
![image](https://github.com/user-attachments/assets/83127892-1f8b-4c40-81c4-0fe832d54226)<br>

## Control Hazards
branch를 할지 말지 알 수 없어서 bubble 발생
- Branch 여부는 ID이후에 나온다. 그래서 바로 IF가 있으면 위험
- In MIPS pipeline
  - registers 비교와 target address 계산을 pipeline 초기에 해야 한다.
  - 이를 위해 ID 단계에서 이 작업을 할 수 있도록 하드웨어를 추가해야 한다.

## Stall on Branch
- branch 결과가 결정될 때까지 기다린 후, 다음 instruction를 가져온다. <br>
![image](https://github.com/user-attachments/assets/2838b4de-6fb3-45da-82f8-882530a5b809)

## Branch Prediction
- 긴 pipelines은 branch 결과를 일찍 결정하기 어려움
- branch 결과를 예측하고, 예측이 틀린 경우에만 Stall을 발생시킨다
- MIPS는 branch가 안일어 난다고 가정하고 다음 instruction을 실행한다.

## More-Realistic Branch Prediction
- Static branch prediction
  - 일반적인 branch 동작에 기반
  - Example: loop and if-statement branches
  - 뒤로 가는 branch(루프)는 taken(jump한다)으로 예측
  - 앞으로 가는 branch(if)는 not taken(다음 줄로 이동)으로 예측
- Dynamic branch prediction
  - Hardware가 실제 브랜치 결과를 측정
    - 각 branch에 대해 history(동작 결과)을 기록
  - 과거 경향을 바탕으로 미래 동작을 예측
    - When wrong, stall while re-fetching, and update history
