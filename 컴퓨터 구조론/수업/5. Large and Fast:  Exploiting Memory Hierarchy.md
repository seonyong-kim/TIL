# 5. Large and Fast: Exploiting Memory Hierarchy
## Principle of Locality
- Programs은 어느 한 시점에 전체 주소 공간 중 일부만 접근한다
- 시간 지역성(Temporal locality)
  - 최근에 접근한 항목은 가까운 시점에 다시 접근할 가능성이 높다
  - 예: 반복문 내의 명령어(instructions in a loop), 반복적으로 사용하는 변수(유도 변수,  induction variables)
- 공간 지역성(Spatial locality)
  - 최근에 접근한 항목 주변에 있는 항목도 곧 접근할 가능성이 높다
  - 예: 순차적인 명령어 접근(sequential instruction access), 배열 데이터(array data)

## Taking Advantage of Locality
- 메모리 계층 구조(Memory hierarchy)
  - 모든 데이터를 디스크(disk)에 저장한다. disk: 느리지만 큰 memory
  - 최근에 접근한 항목(및 그 근처의 항목)을 디스크에서 더 작은 DRAM 메모리로 복사한다. DRAM: 적당히 빠르지만, 약간 작은 memory
    - Main memory = DRAM
  - 더 최근에 접근한 항목(및 그 주변)을 DRAM에서 더 작은 SRAM 메모리로 복사한다. SRAM: 더 작지만 훨씬 빠른 memory
    - 이 SRAM은 CPU에 연결된 캐시 메모리(Cache memory)
   
## Memory Hierarchy Levels
- 블록(Block, 또는 라인 Line): 복사의 단위 (block, line단위로 한꺼번에 가져온다.)
  - 하나의 블록은 여러 워드(word)로 구성될 수 있음(64B, 32B)
- 접근하려는 데이터가 상위 계층(upper level)에 존재할 경우
  - 히트(Hit): 상위 계층에서 접근이 처리됨
    - 히트 비율(Hit ratio): hits(히트 수) / accesses(전체 접근 수)
- 접근하려는 데이터가 존재하지 않을 경우(absent)
  - 미스(Miss): 블록이 하위 계층(lower lever)에서 복사되어 옴
    - 걸리는 시간(Time taken): 미스 패널티(Miss penalty) -> 더 멀리서 가져오면 miss penalty 증가.
    - Miss ratio: misses/accesses <br>
                = 1 - hit ratio
  - 그런 다음, 접근된 데이터는 상위 계층(upper level)으로부터 제공된다. -> 한번 miss를 upper level에서 처리 <br>
  ![image](https://github.com/user-attachments/assets/ce1a04f1-3d60-4e76-aa24-2992daa97c68)

 ## Memory Technology
- Static RAM (SRAM) - cache memory 구성
  - 0.5ns ~ 5ns(1~10 cycle), $400 ~ $800 per GB -> 비싸서 조금만 구성
- Dynamic RAM (DRAM) - main memoey 구성 -> 프로그램에 사용하는 주소 main memory에, 돌아가는 process data는 main memory에
  - 20ns ~ 50ns(40~100 cycle), $2 ~ $4 per GB
- NAND Flash (SSD)
  - 250us ~ 1000us, $0.04 ~ $0.10 per GB
- Magnetic disk(HDD)
  - 2ms ~ 20ms, $0.01 ~ $0.02 per GB
- SSD와 HDD는 storage이다.
- 이상적인 메모리(Ideal memory)
  - SRAM의 접근 속도
  - 디스크의 용량과 GB당 비용
    
 ##  Cache Memory
- 캐시 메모리(Cache memory)
  - CPU에 가장 가까운 메모리 계층 -> 빠르게 접근, 주소로 접근
- 접근한 데이터 X₁, ..., Xₙ₋₁, Xₙ이 주어졌을 때:
  - 해당 데이터가 캐시에 있는지 어떻게 알 수 있을까? -> cache에는 일부 데이터만 있어서
  - 어디에서(어떤 위치에서) 찾아야 할까? <br>

![image](https://github.com/user-attachments/assets/94a0f518-1cce-4384-ba1c-dc1862be2012)

## Direct Mapped Cache
- 위치는 주소(address)에 의해 결정된다
- 직접 매핑 방식(Direct mapped): 선택지는 오직 하나
  - (Block address) modulo (#Blocks in cache)
    - #Blocks은 2의 거듭제곱
    - low-order address bits를 사용한다. <br>

![image](https://github.com/user-attachments/assets/9a6cc1ab-9151-46d3-ba47-e8f9196eb0e6) <br>
8개 block이여서 $2^3$이므로 3개의 하위bit를 사용한다. 그리고 mod 8한 결과에 따라 cache에 넣는다.

## Tags and Valid Bits
- 특정 캐시 위치에 어떤 블록이 저장되어 있는지 어떻게 알 수 있을까?
  - 데이터뿐 아니라 블록 주소도 함께 저장한다
  - 실제로는 주소의 상위 비트만 저장하면 된다
  - Called the **tag**
- 만약 어떤 위치에 데이터가 없으면 어떻게 할까?
  - 유효 비트(valid bit): 1이면 데이터가 존재함, 0이면 데이터가 없음(1 bit사용)
  - Initially 0
- 따라서 과정은 주소 하위 bits -> 위치 찾고 -> ((tag)상위 bits -> 맞는지 확인, valid bit -> 유효한지 확인)

## Cache Example
- 8-blocks, 1 word/block, direct mapped
- Initial state <br>
  ![image](https://github.com/user-attachments/assets/451b9b3f-915a-47a0-91ef-a793e63a5e7c)
- data 접근<br>
  ![image](https://github.com/user-attachments/assets/29df8a8d-abfa-4a0c-9366-71383260d34e)<br>
  결과: <br>
  ![image](https://github.com/user-attachments/assets/f4db652d-3cec-4a45-8dc3-2c05f75f90dd)

- data접근(2)<br>
  ![image](https://github.com/user-attachments/assets/0eb03d2c-8e6d-4dfc-8e6e-1790502d7746)<br>
  결과: <br>
  ![image](https://github.com/user-attachments/assets/4a9ff25f-7d62-4824-a8eb-1f9e017ffccc)

- data접근(3)<br>
  ![image](https://github.com/user-attachments/assets/9c205a0e-ab9d-4d6a-9590-98ee8027c14d)

- data접근(4)<br>
  ![image](https://github.com/user-attachments/assets/8d369a88-3381-4de1-9232-f396a5a96251)

- data접근(5)<br>
  ![image](https://github.com/user-attachments/assets/498cfedb-418b-4850-b985-e1cf995e015c)

## Address Subdivision
![image](https://github.com/user-attachments/assets/fb7bcec8-fdb9-4764-8108-9d426857325a)

## Example: Larger Block Size
![image](https://github.com/user-attachments/assets/c8fec79f-bad2-495b-a478-9ffcc2df6cd8)



