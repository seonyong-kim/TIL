# 4. The Processor
## ALU Control
- Load/Store: F = add
- Branch: F = subtract
- T-type: F는 funct field에 따라 결정<br>
![ALU control](https://github.com/user-attachments/assets/945323c7-95c8-40b5-b362-eba542cd2619)
이 5가지 표현은 3bit면 충분하다.<br>
- ALUOp 2bit가 opcode에서 왔다고 가정

## The Main Control Unit
- opcode에서 파생된 2비트를 ALUOp로 한다
- Combinational logic은 ALU 제어를 파생<br>
![image](https://github.com/user-attachments/assets/7a624270-e584-40c1-a1a6-959be95753ef)
<br> R타입의 경우 뒤에 추가적인 decoding을 한다.
  
## The Main Control Unit
- Control signals은 instruction에서 파생 <br>
![image](https://github.com/user-attachments/assets/cf55f87f-a345-4a97-8325-22bbd103ca06)

## Datapath with Control
![image](https://github.com/user-attachments/assets/445883ae-e24c-46d9-a49c-af8a5b427997)
- RegWrite: R-format, lw: 1 / 나머지는 0
- RegDst: R-format: 1 / lw: 0 / 나머지는 상관없다
- ALUSRC: lw,sw: 1 / R-format, beq: 0
- pcsrc: beq && ALU 결과 조건 만족시: 1 / 나머지는 0
- memwrite: sw: 1 / 나머지는 0
- memread: lw: 1/ 나머지: 0
- memtoReg: lw: 1 / R-format: 0 / 나머지는 상관없다.

## R-Type Instruction
![image](https://github.com/user-attachments/assets/4cd7ac37-a932-4953-b561-35b0a86f7921)
![image](https://github.com/user-attachments/assets/56ce7b39-4cd9-414a-a81f-87c6773ede13)


## Load Instruction
![image](https://github.com/user-attachments/assets/bf2c33da-00ad-4b23-b684-6ab534a23821)
![image](https://github.com/user-attachments/assets/331acd88-2c4e-472e-9157-e518a0033038)

## Branch-on-Equal Instruction
![image](https://github.com/user-attachments/assets/9da5988f-c971-4af7-8f85-c7a3deaa7eb9)

## Implementing Jumps
![image](https://github.com/user-attachments/assets/d780aff1-fa68-4224-82d0-015679f9b109)
- Jump는 word address 사용
- Update PC는 다음과 같이 진행
  - 상위 4-bit는 이전 PC의 상위 4-bit
  - 26-bit는 jump address에 있는거
  - 하위 2-bit는 00으로
- opcode에서 추가 control signal decoded가 필요하다
   
## Datapath with Jumps Added
![image](https://github.com/user-attachments/assets/cbacedf4-dda3-4e7f-a5af-5c38d38ec643)<br>
X는 상관없다는 것을 의미

## Performance Issues
- 가장 긴 delay가 clock period를 결정합니다
  - critical path는 load instruction
  - 과정은 instruction memory -> register file → ALU → data memory → register file
- 명령어에 따라 기간을 변경할 수 없다.
- 설계 원칙 위반
  - 일반적인 사례를 빠르게 처리 -> Load에 맞추면 비효율적이다.
- 파이프라이닝을 통해 성능을 향상시킬 수 있다.

##  Pipelining Analogy
