# Relational DB Design
## F+ ê³„ì‚°ì ˆì°¨
```
 Fâº = F
 repeat
   for each functional dependency f in Fâº
     apply reflexivity and augmentation rules on f
     add the resulting functional dependencies to Fâº
   for each pair of functional dependencies f1 and f2 in Fâº
     if f1 and f2 can be combined using transitivity
       then add the resulting functional dependency to Fâº
 until F + does not change any further
```
reflexivity(ë°˜ì‚¬ì„±)ì™€ augmentation(ì¦ê°•)ì„ fì— ì ìš©í•´ ë” ë§ì€ functional dependenciesë¥¼ ì ìš©í•˜ê³  ë‚˜ì˜¨ ê²°ê³¼ë¥¼ $F^+$ì— ì¶”ê°€í•œë‹¤.<br>
$F^+$ì•ˆì— ìˆëŠ” ë‘ ìŒì— ëŒ€í•´ transitivityê°€ ê°€ëŠ¥í•œì§€ í™•ì¸í•˜ê³  ê°€ëŠ¥í•˜ë©´ ê²°ê³¼ë¥¼ $F^+$ì— ì¶”ê°€í•œë‹¤.<br>
ìœ„ ê³¼ì •ì„ F+ê°€ ë³€í•˜ê¸° ì „ê¹Œì§€ ë°˜ë³µí•œë‹¤. ìµœì•…ì˜ ê²½ìš° O(2^n) F+ì˜ ê°œìˆ˜ë§Œí¼ <br>
- Reflexivity: ì–´ë–¤ ì†ì„±ì´ ìì‹ ì„ í•¨ìˆ˜ì ìœ¼ë¡œ ê²°ì •í•¨ (ex. A â†’ A)
- Augmentation: í•¨ìˆ˜ ì¢…ì†ì„±ì˜ ì–‘ìª½ì— ê°™ì€ ì†ì„±ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŒ (ex. A â†’ Bì´ë©´ AC â†’ BC)<br>
## Closure of Functional Dependencies
- ì¶”ê°€ì ì¸ rules :
  - Î± â†’ Î²ì´ê³ , Î± â†’ Î³ë¼ë©´, Î± â†’ Î²Î³ë„ ì„±ë¦½í•œë‹¤ (union) <br>
    ì¦ëª… : Î±Î± -> Î±Î², Î±Î± -> Î± ì´ë¯€ë¡œ Î± -> Î±Î², Î±Î² -> Î²Î³ ì´ë‹¤.
  - Î± â†’ Î²Î³ê°€ ì„±ë¦½í•˜ë©´, Î± â†’ Î²ë„ ì„±ë¦½í•˜ê³  Î± â†’ Î³ë„ ì„±ë¦½í•œë‹¤ (decomposition) <br>
    ì¦ëª… : Î²Î³ -> Î² and Î²Î³ -> Î³ ì´ë©´ Î± -> Î²Î³ -> Î² ì´ê³ , Î± -> Î²Î³ -> Î³ ì´ë‹¤.
  - Î± â†’ Î²ì´ê³ , Î³Î² â†’ Î´ë¼ë©´, Î±Î³ â†’ Î´ë„ ì„±ë¦½í•œë‹¤ (pseudotransitivity) <br>
    ì¦ëª… : Î± â†’ Î² ì´ë©´ Î±Î³ -> Î²Î³ -> Î´

## Closure of Attribute Sets
- set of attributes(ì†ì„± ì§‘í•©) Î±ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, Fì— ëŒ€í•œ closure of Î±(Î±âº)ë¥¼, Fì— ì˜í•´ Î±ë¡œë¶€í„° í•¨ìˆ˜ì ìœ¼ë¡œ ê²°ì •ë˜ëŠ” ì†ì„±ë“¤ì˜ ì§‘í•©ìœ¼ë¡œ ì •ì˜í•œë‹¤.
- Î±âº(closure of Î±)ë¥¼ Fì— ë”°ë¼ ê³„ì‚°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.
``` 
result := Î±;
 while (changes to result) do
 for each Î² â†’ Î³ in F do
 begin
 if Î² âŠ† result then result := result âˆª Î³
 end
```
Î± â†’ result ì´ê³  Î² â†’ Î³ ì¼ë•Œ ifë¶€ë¶„ ë§Œì¡±ì‹œ result â†’ Î² ì´ë¯€ë¡œ Î± â†’ Î³ ì´ë‹¤.

### Example of Attribute Set Closure
- R = (A, B, C, G, H, I)
- F = {A â†’ B, A â†’ C, CG â†’ H, CG â†’ I, B â†’ H}
- $(AG)^+$ ì£¼ì–´ì§„ í•¨ìˆ˜ì  ì¢…ì†ì„± ì§‘í•© F ì•„ë˜ì—ì„œ (AG)âºë¥¼ ê³„ì‚°í•œ ê²°ê³¼:
1. result = AG
2. A â†’ B, A â†’ C ì‚¬ìš© â†’ result = ABCG
3. CG â†’ H ì‚¬ìš© ê°€ëŠ¥ (CG âŠ† ABCG) â†’ result = ABCGH
4. CG â†’ I ì‚¬ìš© ê°€ëŠ¥ (CG âŠ† ABCGH) â†’ result = ABCGHI
ìµœì¢…ì ìœ¼ë¡œ (AG)âº = {A, B, C, G, H, I} AGì—ì„œ ëª¨ë“ ê²ƒìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ superkeyì´ë‹¤.
- AGëŠ” ìŠˆí¼í‚¤ì¸ê°€?
  - $A^+$ì— ëŒ€í•´
  1. result = $A^+$
  2. result = ABC
  3. result = ABCH -> AëŠ” keyX
  - $G^+$ì— ëŒ€í•´
  1. result = G -> Gë„ keyX <br>
ë”°ë¼ì„œ $AG^+$ëŠ” cadidate keyì´ë‹¤.

## Uses of Attribute Closure
there are several uses of the attribute closure algorithm:
- Testing for Superkey :<br>
  Î±ê°€ ìŠˆí¼í‚¤ì¸ì§€ í™•ì¸í•˜ë ¤ë©´, Î±âºë¥¼ ê³„ì‚°í•˜ê³  R(ë¦´ë ˆì´ì…˜ì˜ ëª¨ë“  ì†ì„±)ì„ í¬í•¨í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤.
- Testing Functional Dependencies :<br>
  í•¨ìˆ˜ì  ì¢…ì†ì„± Î± â†’ Î²ê°€ ì„±ë¦½í•˜ëŠ”ì§€(Fâºì— í¬í•¨ë˜ëŠ”ì§€) í™•ì¸í•˜ë ¤ë©´, Î±âºë¥¼ êµ¬í•´ì„œ Î²ê°€ ê·¸ ì•ˆì— í¬í•¨ë˜ëŠ”ì§€ í™•ì¸í•˜ë©´ ëœë‹¤. 
- Computing Closure of F (Fâº êµ¬í•˜ê¸°) :<br>
  $F^+$ë¥¼ ë‹¤ êµ¬í•´ì„œ Unionì„ í†µí•´ êµ¬í•  ìˆ˜ ìˆë‹¤.

## Lossless-join Decomposition
- R = (Râ‚, Râ‚‚)ë¡œ ìª¼ê°  í›„, we require that for all possible relations r on schema R <br>
r = Ï€_Râ‚(r) â¨ Ï€_Râ‚‚(r) -> ê°ê° ìª¼ê° ê²ƒì„ joiní•˜ë©´ Rë¡œ ì›ìƒë³µêµ¬ ê°€ëŠ¥í•˜ë‹¤.
- Rì„ Râ‚ê³¼ Râ‚‚ë¡œ decompositioní•œ ê²ƒì´ lossless joinì´ ë˜ë ¤ë©´, ë‹¤ìŒ ì¢…ì†ì„±ë“¤ ì¤‘ ì ì–´ë„ í•˜ë‚˜ê°€ Fâºì— í¬í•¨ë˜ì–´ ìˆì–´ì•¼ í•œë‹¤:
  - Râ‚ âˆ© Râ‚‚ â†’ Râ‚
  - Râ‚ âˆ© Râ‚‚ â†’ Râ‚‚ <br>

ë”°ë¼ì„œ, Râ‚ê³¼ Râ‚‚ì˜ êµì§‘í•©ì´ Râ‚ ë˜ëŠ” Râ‚‚ ì¤‘ ì ì–´ë„ í•˜ë‚˜ì˜ ìŠˆí¼í‚¤(superkey)ë¥¼ ì´ë£¨ë©´, Rì˜ decompositionëŠ” lossless decompositionì´ë‹¤.
- ì°¸ê³ ì‚¬í•­ : <br>
  R = (A,B,C) -> attribute ì§‘í•© / r(A,B,C) -> relation

### Example
- R = (A, B, C) <br>
F = {A â†’ B, B â†’ C) Aê°€ keyì´ë‹¤. <br>

2ê°€ì§€ ë‹¤ë¥¸ ë°©ë²•ìœ¼ë¡œ ìª¼ê°¤ ìˆ˜ ìˆë‹¤.
1. R1 = (A, B),   R2 = (B, C),  Cê°€ Aì˜ keyì¼ ë•Œ
- Lossless-join decomposition : R1 âˆ© R2 = {B} and B â†’ BC ì´ë¯€ë¡œ R1 âˆ© R2 = R2(={BC})ì´ë‹¤. <br>
ë”°ë¼ì„œ Dependency preserving
2. R1 = (A, B),   R2 = (A, C),  Cê°€ Aì˜ keyì¼ ë•Œ
- Lossless-join decomposition : R1 âˆ© R2 = {A} and A â†’ AB R1 âˆ© R2 = R1(={AB})ì´ë‹¤. <br>
í•˜ì§€ë§Œ Not dependency preserving B -> Cë¥¼ ë°”ë¡œ í™•ì¸ ë¶ˆê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì´ë‹¤.

## Dependency Preservation
Fáµ¢ëŠ” Fâºì¤‘ì—ì„œ Ráµ¢ì— í¬í•¨ëœ attributesë§Œ ì‚¬ìš©í•˜ëŠ” set of dependenciesì´ë‹¤.
- ë‹¤ìŒ ì¡°ê±´ì´ ë§Œì¡±ë˜ë©´ ê·¸ ë¶„í•´ëŠ” í•¨ìˆ˜ì  ì¢…ì†ì„± ë³´ì¡´(dependency preserving)ì´ë¼ í•œë‹¤: <br>
(Fâ‚ âˆª Fâ‚‚ âˆª â€¦ âˆª Fâ‚™)âº = Fâº
- ì´ ì¡°ê±´ì´ ë§Œì¡±ë˜ì§€ ì•Šìœ¼ë©´, í•¨ìˆ˜ì  ì¢…ì†ì„± ìœ„ë°˜ ì—¬ë¶€ë¥¼ ê²€ì‚¬í•˜ë ¤ë©´ relationë“¤ì„ joiní•´ì•¼ í•˜ë©°, ì´ëŠ” ë¹„ìš©ì´ ë§ì´ ë“ ë‹¤.

### Example
- R = (A, B, C) <br>
F = {A â†’ B, B â†’C} -> Key = {A} <br>
R is not in BCNF : BëŠ” í›„ë³´ í‚¤ê°€ ì•„ë‹Œë° ê²°ì •ìì—¬ì„œ -> BCNF ìœ„ë°˜
- Decomposition R1 = (A, B),  R2 = (B, C) <br>
R1 and R2 in BCNF <br>
Lossless-join decomposition: ë¶„í•´í•œ $R_1$ê³¼ $ğ‘…_2$ ë¥¼ ë‹¤ì‹œ ê²°í•©í•´ë„ ì›ë˜ì˜ ğ‘…ì„ ì™„ì „íˆ ë³µì›í•  ìˆ˜ ìˆë‹¤.<br>
Dependency preserving: ì›ë˜ ë¦´ë ˆì´ì…˜ì—ì„œì˜ ëª¨ë“  í•¨ìˆ˜ ì¢…ì†ì„±ì„ ë¶„í•´ í›„ì—ë„ ê°ê°ì˜ ë¶„í•´ ë¦´ë ˆì´ì…˜ì—ì„œ ê·¸ëŒ€ë¡œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

## BCNF and Dependency Preservation
í•­ìƒ BCNF decompositionê°€ Dependency Preservationì„ ë§Œì¡±í•˜ëŠ” ê²ƒì€ ì•„ë‹ˆë‹¤.
- R = (J, K, L) / F = {JK â†’ L, L â†’ K}  candidate keyëŠ” JKì™€ JL ë‘ ê°œ <br>
Rì€ BCNFë¥¼ ë§Œì¡±í•˜ì§€ ì•ŠëŠ”ë‹¤ <br>
- ì´ìœ  : L â†’ KëŠ” BCNF ìœ„ë°˜ (Lì€ ìŠˆí¼í‚¤ê°€ ì•„ë‹˜, non trivaial) <br>
ë‹¨, këŠ” cadidate keyì˜ ì¼ë¶€ì´ë¯€ë¡œ 3NF ê°€ëŠ¥ -> ë”°ë¼ì„œ decomposeí•  í•„ìš”ê°€ ì—†ë‹¤.
Rì„ ì–´ë–»ê²Œ ë¶„í•´í•˜ë“  ê°„ì—, JK â†’ L ì´ë¼ëŠ” ì¢…ì†ì„±ì„ ë¶„í•´ëœ ë¦´ë ˆì´ì…˜ë“¤ ì•ˆì—ì„œ ìœ ì§€í•  ìˆ˜ ì—†ë‹¤. <br>
ë”°ë¼ì„œ ì´ ì¢…ì†ì„±ì„ í™•ì¸í•˜ë ¤ë©´, ë¶„í•´ëœ ë¦´ë ˆì´ì…˜ë“¤ì„ ì¡°ì¸(join) í•´ì•¼ í•œë‹¤.

## Comparison of BCNF and 3NF
- 3NFì˜ ê²½ìš°:
  - í•­ìƒ ì–´ë–¤ ë¦´ë ˆì´ì…˜ì´ë“  3NFë¡œ ë¶„í•´í•  ìˆ˜ ìˆë‹¤.
  - decomposition losslessê°€ ê°€ëŠ¥í•˜ê³ 
  - ëª¨ë“  dependencies preserved í•  ìˆ˜ ìˆë‹¤.
- BCNFì˜ ê²½ìš°:
  - ëª¨ë“  ë¦´ë ˆì´ì…˜ì„ BCNFë¡œ ë¶„í•´í•˜ëŠ” ê²ƒì€ ê°€ëŠ¥í•˜ì§€ë§Œ
  - decomposition losslessëŠ” ê°€ëŠ¥í•´ë„
  - preserve dependenciesê°€ í•­ìƒ ê°€ëŠ¥í•œ ê²ƒì€ ì•„ë‹ˆë‹¤

## Design Goals
- Goal for a relational database design is:
  - BCNF.
  - Lossless join.
  - Dependency preservation.
- If we cannot achieve this, we accept one of(í•˜ë‚˜ë§Œ ì„ íƒ)
  - Lack of dependency preservation
  - Redundancy due to use of 3NF
-SQLì€ ìŠˆí¼í‚¤(superkey) ì´ì™¸ì˜ ë‹¤ë¥¸ í•¨ìˆ˜ì  ì¢…ì†ì„±ì„ ì§ì ‘ì ìœ¼ë¡œ ëª…ì‹œí•˜ëŠ” ë°©ë²•ì„ ì œê³µí•˜ì§€ ì•ŠëŠ”ë‹¤.<br>
í•¨ìˆ˜ì  ì¢…ì†ì„±(FD)ì€ ASSERTIONì„ ì‚¬ìš©í•´ì„œ ëª…ì‹œí•  ìˆ˜ ìˆì§€ë§Œ, í…ŒìŠ¤íŠ¸ ë¹„ìš©ì´ ë§¤ìš° í¬ë©°, í˜„ì¬ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” ë°ì´í„°ë² ì´ìŠ¤ ì‹œìŠ¤í…œë“¤ì—ì„œëŠ” ì§€ì›ë˜ì§€ ì•ŠëŠ”ë‹¤!
- dependency preserving ë¶„í•´ë¥¼ í–ˆë”ë¼ë„,
SQLì—ì„œëŠ” ì¢Œë³€ì´ í‚¤ê°€ ì•„ë‹Œ í•¨ìˆ˜ì  ì¢…ì†ì„±ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê²€ì‚¬í•  ìˆ˜ ì—†ë‹¤. <br>
ë”°ë¼ì„œ BCNFë¡œ ìª¼ê°œëŠ”ê²Œ ë” ì¢‹ë‹¤.
