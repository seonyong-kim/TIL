# Storage and File Structures
## Storage Hierarchy <br>
![image](https://github.com/user-attachments/assets/b7871d18-3a5e-47fa-b1f1-cd997b0bc96a)

## 물리적 저장 매체
- Cache: 가장 빠르고 가장 비싼 형태의 storage; 휘발성; hardware에 의해 관리된다.
  - 접근 시간: a few nanoseconds ($10^{-9}$ seconds)
- Main memory (RAM)
  - 접근 시간: a few hundreds nanoseconds ($10^{-7}$ seconds)
  - 휘발성: 전원 장애나 시스템 충돌 시 메모리 내용은 일반적으로 손실된다.
- Flash memory
  – 비휘발성
  - 접근 시간: under a hundred microseconds ($10^{-4}$ ~ $10^{-5}$ seconds)
    - Slower than RAM, but faster than magnetic disks
- Magnetic-disk
  - 비휘발성
  - 접근시간: a few milliseconds ($10^{-3}$ seconds)
  - main memory보다 훨씬 느림
  - 데이터를 접근하려면 디스크에서 메인 메모리로 옮겨야 하며, 저장하려면 다시 디스크에 써야 한다.

## File Organization
- The database는 각 files들의 모음으로 저장된다.
  - 각 file은 records들의 순서로 구성된다. 
    - record는 fields들의 순서로 구성된다.
  - 각 file은 fixed-length storage units인 blocks으로 분할된다. <br>
  (block은 저장 할당과 데이터 전송의 단위)
    - 하나의 block에는 여러 개의 records가 포함될 수 있다.
- file 안의 recored를 어떻게 구성할 것인가?
  - 다음과 같은 가정을 한다..
    - Each file은 한 가지 유형의 records만 포함하고, 다른 relations는 다른 files에 저장된다.
  - records 2가지 유
    - Fixed-length records(고정 길이 레코드)
    - Variable-length records(가변 길이 레코드)
   
## External-Memory Model
- EM Model은 RAM (main memory) model과 다르
  - Time Complexity in RAM model
    - The number of basic operations (e.g., memory access)
  - I/O Complexity in EM model
    - Thenumberof I/O’s (read/write from/to external memory)<br>
![image](https://github.com/user-attachments/assets/da007c7d-5f72-4f39-8d53-d54b15c6a946) <br>

| 비교할 거 | RAM Model | External Memory (EM) Model |
|---------------|-----------------------|-------------------------------------|
| Time | O(#basic operations) | I/O: O(#I/O’s (read and write)) |

<br> Linear I/O: O($N \over B$) < O(N)
- 일반적으로 사용되는 표기
  - N: data file에 있는 record의 수
  - M: main memory에 들어갈 수 있는 record의 수
  - B: 하나의 block에 들어갈 수 있는 record의 수

## Fixed-Length Records
``` sql
create table instructor (
 ID            char(5),       /* 5 bytes */
 name          varchar(20),   /* 20 bytes at most */
 dept_name     varchar(20),   /* 20 bytes at most */
 salary        numeric(8,2),  /* 8 bytes */
 primary key (ID),
 foreign key (dept_name) references department)
```
![image](https://github.com/user-attachments/assets/0e2b3b34-082e-4422-8fb9-604973225e62)<br>
- Simple approach:
  - 각 record i는 byte n * (i– 1)위치 부터 저장하기 시작한다.(n은 record의 크기이다)
  - Record 접근은 간단하지만, records가 blocks 경계를 넘을 수 있다.
    - 일반적인 가정: records가 block boundaries넘지 않도록 허용하지 않는다.
- record i 삭제:
  - (단순한 방법) i+1 부터 n까지 모든 레코드를 i부터 n-1까지 앞으로 이동한다.<br>
![image](https://github.com/user-attachments/assets/864ad417-6a26-4689-8f82-0e59845b8d38)<br>
밑에거 부터 채우고, 채워지면 제자리로간다. 이런식으로 전부 진행하면서 채운다. -> O($N \over B$)I/O
  - (개선 방법)
    - record n을 i로 이동한다. 
    - records를 이동하지 않고,모든 빈 record를 free list에 연결한다.<br>
![image](https://github.com/user-attachments/assets/c328865b-b5eb-45a8-add2-1cd7831405bf)

### Deleting record 3
![image](https://github.com/user-attachments/assets/6c2b322a-df9f-4093-8feb-502f308053b2)

## Maintaining Free Lists(삭제시 채우기보다는 그냥 비워두는 방법)
- file header에 첫 번째로 삭제된 record의 주소를 저장한다.
- 이 first record에 second deleted record의 주소를 저장, 이런식으로 계속 연결한다.
- 이러한 stored addresses를 pointers로 생각할 수 있는데, 이는 record의 위치를 가리키기 때문이다
- 더 space 효율적인 표현: 삭제된 레코드의 일반 속성 공간을 재사용하여 포인터를 저장한다. <br>
  (사용중인 records에는 포인터를 저장하지 않는다.) <br>
![image](https://github.com/user-attachments/assets/d9807fd0-8488-4780-bd98-ed3acdea0089) 
![image](https://github.com/user-attachments/assets/c8916881-42bd-45a8-9fa3-d9a7674b6db6)

