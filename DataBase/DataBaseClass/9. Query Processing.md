# 9. Query Processing
## Recap: Basic Query Structure 
- A typical SQL query has the form:
  ```SQL
  select A1, A2, ..., An
  from r1, r2, ..., rm
  where P
  ```
  - $A_i$는 속성(attribute)을 나타낸다
  - $R_i$는 릴레이션(relation)을 나타낸다
  - P는 술어(predicate)를 나타낸다
- The result of an SQL query is a relation.
- E.g.,
  select name
  from instructor
  where dept_name = ‘Comp. Sci.' and salary > 80000

## Basic Steps in Query Processing(Query 실행순서)
1. Parsing and tanslation
2. Optimization(최적화)
3. Evaluation(평가)<br>

![image](https://github.com/user-attachments/assets/cdab88b3-1fcb-4b05-8a73-174f69100e8d)

## Basic Steps: Optimization 
- Query Optimization: 모든 동등한 실행 계획 중에서 lowest cost를 선택
  - 비용은 database catalog의 statistical information를 사용하여 추정됨
    - e.g. 각 릴레이션의 튜플 수, 튜플 크기 등

## Measures of Query Cost
- Cost는 일반적으로 answering query에 걸리는 total elapsed(경과) time으로 측정된다.
  - time cost에는 여러 요소가 기여함(디스크 접근, CPU 사용, 네트워크 통신 등)
- 일반적으로 disk access이 predominant cost(가장 큰 비용)이며, 비교적 추정이 쉬움. 다음을 고려하여 측정한다:
  - Number of blocks read: 평균 탐색 비용 + 블록 읽기 비용
  - Number of blocks written: 평균 블록 쓰기 비용
    - Cost to write a block이 cost to read a block보다 크다 -> 쓰기가 성공적으로 이루어졌는지 확인하기 위해 데이터를 다시 읽기 때문
   
## Measures of Query Cost (Cont.)
- Several algorithms은 extra buffer space를 활용하여 disk I/O를 줄일 수 있다.
  - buffer에 사용할 수 있는 real memory 양은 다른 concurrent queries나 OS processes에 따라 달라지며, 이는 execution(실행) 시에만 알 수 있음
    - 따라서 일반적으로는 작업에 필요한 minimum amount of memory만 사용 가능한 worst case 추정한다.
- Required data가 이미 buffer에 존재하는 경우, disk I/O를 피할 수 있다.

## Recap: I/O complexity model
- simplicity(단순화)를 위해 disk에서 전송되는 블록 수만 사용한다.
  - M: memory size (메인 메모리에 들어갈 수 있는 튜플 수)
  - B: block size (하나의 블록에 들어갈 수 있는 튜플 수)
  - N: relation에 있는 튜플 수 (예: $N_s$, $N_r$ 등)
  - Linear I/O: O(N/B)
  - Logarithmic I/O: O($log_B N$)
- 단순화를 위해 CPU costs 및 seek(탐색) costs은 무시한다.
  - 실제 시스템에서는 CPU costs도 고려한다.
 
## Selection Operation
- File scan(전체 파일을 읽는다)
- Algorithm A1 (linear search): 각 파일 블록을 순차적으로 스캔하고 모든 레코드가 selection condition을 만족하는지 검사한다.
  - I/O Cost = O(N / B)
  - Linear search는 다음과 무관하게 적용 가능함:
    - selection condition(선택 조건)
    - 파일 내 레코드의 정렬 여부
    - 인덱스 존재 여부
- 만약 M > N인 충분히 큰 메모리가 있다면?
  - 여전히 N개의 tuples, 즉 N / B개의 블록을 메모리에 로드해야 한다.
 
## Selections Using Indices
- Index scan: index를 사용하는 search algorithms
  - selection condition은 인덱스의 search-key에 있어야 함
- A2 (primary $B^+$-tree index, equality on key). 해당 equality condition을 만족하는 single record를 검색한다 <br>
  여기서 equality on key는 DB key의미로 해당하는 record가 1개만 있다.
  - Exact search -> I/O 비용: O($\log_B N$) <br>
  ![image](https://github.com/user-attachments/assets/f432a6f7-8b8b-4425-85e1-dd1d9509418f) <br>
- A3 (primary B+-tree index, equality on non-key). same search-key value을 가진 multiple records를 검색한다.
  - T = search-key value을 가지는 레코드 수 -> I/O 비용: O($\log_B N + \frac{T}{B}$) <br>
  ![image](https://github.com/user-attachments/assets/09174328-cd52-462a-b545-13204b2994fc) <br>
