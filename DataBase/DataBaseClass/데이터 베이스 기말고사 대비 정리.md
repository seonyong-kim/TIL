# Relational DB Design
## F+ ê³„ì‚°ì ˆì°¨
```
 Fâº = F
 repeat
   for each functional dependency f in Fâº
     apply reflexivity and augmentation rules on f
     add the resulting functional dependencies to Fâº
   for each pair of functional dependencies f1 and f2 in Fâº
     if f1 and f2 can be combined using transitivity
       then add the resulting functional dependency to Fâº
 until F + does not change any further
```
reflexivity(ë°˜ì‚¬ì„±)ì™€ augmentation(ì¦ê°•)ì„ fì— ì ìš©í•´ ë” ë§ì€ functional dependenciesë¥¼ ì ìš©í•˜ê³  ë‚˜ì˜¨ ê²°ê³¼ë¥¼ $F^+$ì— ì¶”ê°€í•œë‹¤.<br>
$F^+$ì•ˆì— ìˆëŠ” ë‘ ìŒì— ëŒ€í•´ transitivityê°€ ê°€ëŠ¥í•œì§€ í™•ì¸í•˜ê³  ê°€ëŠ¥í•˜ë©´ ê²°ê³¼ë¥¼ $F^+$ì— ì¶”ê°€í•œë‹¤.<br>
ìµœì•…ì˜ ê²½ìš° O($2^n$) ì˜ Fê°œìˆ˜ ë§Œí¼
- Reflexivity: A â†’ A (ìê¸° ìì‹ ì„ í•¨ìˆ˜ë¡œ)  /  Augmentation: ì–‘ìª½ì— ê°™ì€ ì†ì„± ì¶”ê°€ A â†’ Bì´ë©´ AC â†’ BC

## Closure of Functional Dependencies
- Î± â†’ Î²ì´ê³ , Î± â†’ Î³ë¼ë©´, Î± â†’ Î²Î³ë„ ì„±ë¦½í•œë‹¤ (union)
- Î± â†’ Î²Î³ê°€ ì„±ë¦½í•˜ë©´, Î± â†’ Î²ë„ ì„±ë¦½í•˜ê³  Î± â†’ Î³ë„ ì„±ë¦½í•œë‹¤ (decomposition)
- Î± â†’ Î²ì´ê³ , Î³Î² â†’ Î´ë¼ë©´, Î±Î³ â†’ Î´ë„ ì„±ë¦½í•œë‹¤ (pseudotransitivity)

## Closure of Attribute Sets
- set of attributes(ì†ì„± ì§‘í•©) Î±ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, Fì— ëŒ€í•œ closure of Î±(Î±âº)ë¥¼, Fì— ì˜í•´ Î±ë¡œë¶€í„° í•¨ìˆ˜ì ìœ¼ë¡œ ê²°ì •ë˜ëŠ” ì†ì„±ë“¤ì˜ ì§‘í•©ìœ¼ë¡œ ì •ì˜í•œë‹¤.
``` 
result := Î±;
 while (changes to result) do
 for each Î² â†’ Î³ in F do
 begin
 if Î² âŠ† result then result := result âˆª Î³
end
```
Î± â†’ result ì´ê³  Î² â†’ Î³ ì¼ë•Œ ifë¶€ë¶„ ë§Œì¡±ì‹œ result â†’ Î² ì´ë¯€ë¡œ Î± â†’ Î³ ì´ë‹¤.

### Example of Attribute Set Closure
- R = (A, B, C, G, H, I)  /  F = {A â†’ B, A â†’ C, CG â†’ H, CG â†’ I, B â†’ H}
- $(AG)^+$ ì£¼ì–´ì§„ í•¨ìˆ˜ì  ì¢…ì†ì„± ì§‘í•© F ì•„ë˜ì—ì„œ (AG)âºë¥¼ ê³„ì‚°í•œ ê²°ê³¼:
1. result = AG
2. A â†’ B, A â†’ C ì‚¬ìš© â†’ result = ABCG
3. CG â†’ H ì‚¬ìš© ê°€ëŠ¥ (CG âŠ† ABCG) â†’ result = ABCGH
4. CG â†’ I ì‚¬ìš© ê°€ëŠ¥ (CG âŠ† ABCGH) â†’ result = ABCGHI <br>
ìµœì¢…ì ìœ¼ë¡œ (AG)âº = {A, B, C, G, H, I} AGì—ì„œ ëª¨ë“ ê²ƒìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆìœ¼ë¯€ë¡œ superkeyì´ë‹¤.
- AGëŠ” cadidate keyì¸ê°€?
  - $A^+$ì— ëŒ€í•´
  1. result = $A^+$
  2. result = ABC
  3. result = ABCH -> AëŠ” keyX
  - $G^+$ì— ëŒ€í•´
  1. result = G -> Gë„ keyX <br>
ë”°ë¼ì„œ $AG^+$ëŠ” cadidate keyì´ë‹¤.

## Uses of Attribute Closure
there are several uses of the attribute closure algorithm:
- Testing for Superkey:<br>
  Î±ê°€ ìŠˆí¼í‚¤ì¸ì§€ í™•ì¸í•˜ë ¤ë©´, Î±âºë¥¼ ê³„ì‚°í•˜ê³  R(ë¦´ë ˆì´ì…˜ì˜ ëª¨ë“  ì†ì„±)ì„ í¬í•¨í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤.
- Testing Functional Dependencies:<br>
  í•¨ìˆ˜ì  ì¢…ì†ì„± Î± â†’ Î²ê°€ ì„±ë¦½í•˜ëŠ”ì§€(Fâºì— í¬í•¨ë˜ëŠ”ì§€) í™•ì¸í•˜ë ¤ë©´, Î±âºë¥¼ êµ¬í•´ì„œ Î²ê°€ ê·¸ ì•ˆì— í¬í•¨ë˜ëŠ”ì§€ í™•ì¸í•˜ë©´ ëœë‹¤. 
- Computing Closure of F (Fâº êµ¬í•˜ê¸°) :<br>
  $F^+$ë¥¼ ë‹¤ êµ¬í•´ì„œ Unionì„ í†µí•´ êµ¬í•  ìˆ˜ ìˆë‹¤.

## Lossless-join Decomposition
- R = (Râ‚, Râ‚‚)ë¡œ ìª¼ê°  í›„,  ê°ê° ìª¼ê° ê²ƒì„ joiní•˜ë©´ Rë¡œ ì›ìƒë³µêµ¬ ê°€ëŠ¥
- Rì„ Râ‚ê³¼ Râ‚‚ë¡œ decompositioní•œ ê²ƒì´ lossless joinì´ ë˜ë ¤ë©´, ë‹¤ìŒ ì¢…ì†ì„±ë“¤ ì¤‘ ì ì–´ë„ í•˜ë‚˜ê°€ Fâºì— í¬í•¨ë˜ì–´ ìˆì–´ì•¼ í•œë‹¤:
  - Râ‚ âˆ© Râ‚‚ â†’ Râ‚
  - Râ‚ âˆ© Râ‚‚ â†’ Râ‚‚ <br>

ë”°ë¼ì„œ, Râ‚ê³¼ Râ‚‚ì˜ êµì§‘í•©ì´ Râ‚ ë˜ëŠ” Râ‚‚ ì¤‘ ì ì–´ë„ í•˜ë‚˜ì˜ ìŠˆí¼í‚¤(superkey)ë¥¼ ì´ë£¨ë©´, Rì˜ decompositionëŠ” lossless decompositionì´ë‹¤.
- ì°¸ê³ ì‚¬í•­ : <br>
  R = (A,B,C) -> attribute ì§‘í•© / r(A,B,C) -> relation

### Example
- R = (A, B, C) <br>
F = {A â†’ B, B â†’ C) Aê°€ keyì´ë‹¤. <br>

2ê°€ì§€ ë‹¤ë¥¸ ë°©ë²•ìœ¼ë¡œ ìª¼ê°¤ ìˆ˜ ìˆë‹¤.
1. R1 = (A, B),   R2 = (B, C)
- Lossless-join decomposition : R1 âˆ© R2 = {B} and B â†’ BC ì´ë¯€ë¡œ R1 âˆ© R2 = R2(={BC})ì´ë‹¤. <br>
ë”°ë¼ì„œ Dependency preserving
2. R1 = (A, B),   R2 = (A, C)
- Lossless-join decomposition : R1 âˆ© R2 = {A} and A â†’ AB R1 âˆ© R2 = R1(={AB})ì´ë‹¤. <br>
í•˜ì§€ë§Œ Not dependency preserving B -> Cë¥¼ ë°”ë¡œ í™•ì¸ ë¶ˆê°€ëŠ¥í•˜ê¸° ë•Œë¬¸

## Dependency Preservation
Fáµ¢ëŠ” Fâºì¤‘ì—ì„œ Ráµ¢ì— í¬í•¨ëœ attributesë§Œ ì‚¬ìš©í•˜ëŠ” set of dependenciesì´ë‹¤.
- ë‹¤ìŒ ì¡°ê±´ì´ ë§Œì¡±ë˜ë©´ ê·¸ ë¶„í•´ëŠ” í•¨ìˆ˜ì  ì¢…ì†ì„± ë³´ì¡´(dependency preserving)ì´ë¼ í•œë‹¤: <br>
(Fâ‚ âˆª Fâ‚‚ âˆª â€¦ âˆª Fâ‚™)âº = Fâº
- ì´ ì¡°ê±´ì´ ë§Œì¡±ë˜ì§€ ì•Šìœ¼ë©´, í•¨ìˆ˜ì  ì¢…ì†ì„± ìœ„ë°˜ ì—¬ë¶€ë¥¼ ê²€ì‚¬í•˜ë ¤ë©´ relationë“¤ì„ joiní•´ì•¼ í•˜ë©°, ì´ëŠ” ë¹„ìš©ì´ ë§ì´ ë“ ë‹¤.

### Example
- R = (A, B, C),  F = {A â†’ B, B â†’C} -> Key = {A} <br>
R is not in BCNF : BëŠ” í›„ë³´ í‚¤ê°€ ì•„ë‹Œë° ê²°ì •ìì—¬ì„œ -> BCNF ìœ„ë°˜
- Decomposition R1 = (A, B),  R2 = (B, C) <br>
R1 and R2 in BCNF <br>
Lossless-join decomposition: ë¶„í•´í•œ $R_1$ê³¼ $ğ‘…_2$ ë¥¼ ë‹¤ì‹œ ê²°í•©í•´ë„ ì›ë˜ì˜ ğ‘…ì„ ì™„ì „íˆ ë³µì›í•  ìˆ˜ ìˆë‹¤.<br>
Dependency preserving: ì›ë˜ ë¦´ë ˆì´ì…˜ì—ì„œì˜ ëª¨ë“  í•¨ìˆ˜ ì¢…ì†ì„±ì„ ë¶„í•´ í›„ì—ë„ ê°ê°ì˜ ë¶„í•´ ë¦´ë ˆì´ì…˜ì—ì„œ ê·¸ëŒ€ë¡œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

## BCNF and Dependency Preservation
í•­ìƒ BCNF decompositionê°€ Dependency Preservationì„ ë§Œì¡±í•˜ëŠ” ê²ƒì€ ì•„ë‹ˆë‹¤.
- R = (J, K, L) / F = {JK â†’ L, L â†’ K}  candidate keyëŠ” JKì™€ JL ë‘ ê°œ <br>
Rì€ BCNFë¥¼ ë§Œì¡±í•˜ì§€ ì•ŠëŠ”ë‹¤ <br>
- ì´ìœ  : L â†’ KëŠ” BCNF ìœ„ë°˜ (Lì€ ìŠˆí¼í‚¤ê°€ ì•„ë‹˜, non trivaial) <br>
ë‹¨, këŠ” cadidate keyì˜ ì¼ë¶€ì´ë¯€ë¡œ 3NF ê°€ëŠ¥ -> ë”°ë¼ì„œ decomposeí•  í•„ìš”ê°€ ì—†ë‹¤.

## Comparison of BCNF and 3NF
- 3NFì˜ ê²½ìš°:
  - í•­ìƒ ì–´ë–¤ ë¦´ë ˆì´ì…˜ì´ë“  3NFë¡œ ë¶„í•´í•  ìˆ˜ ìˆë‹¤.
  - decomposition losslessê°€ ê°€ëŠ¥í•˜ê³ 
  - ëª¨ë“  dependencies preserved í•  ìˆ˜ ìˆë‹¤.
- BCNFì˜ ê²½ìš°:
  - ëª¨ë“  ë¦´ë ˆì´ì…˜ì„ BCNFë¡œ ë¶„í•´í•˜ëŠ” ê²ƒì€ ê°€ëŠ¥í•˜ì§€ë§Œ
  - decomposition losslessëŠ” ê°€ëŠ¥í•´ë„
  - preserve dependenciesê°€ í•­ìƒ ê°€ëŠ¥í•œ ê²ƒì€ ì•„ë‹ˆë‹¤

## Design Goals
- Goal for a relational database design is:
  - BCNF  /  Lossless join  /  Dependency preservation
- If we cannot achieve this, we accept one of(í•˜ë‚˜ë§Œ ì„ íƒ)
  - Lack of dependency preservation
  - Redundancy due to use of 3NF
-SQLì€ ìŠˆí¼í‚¤(superkey) ì´ì™¸ì˜ ë‹¤ë¥¸ í•¨ìˆ˜ì  ì¢…ì†ì„±ì„ ì§ì ‘ì ìœ¼ë¡œ ëª…ì‹œí•˜ëŠ” ë°©ë²•ì„ ì œê³µí•˜ì§€ ì•ŠëŠ”ë‹¤.<br>
í•¨ìˆ˜ì  ì¢…ì†ì„±(FD)ì€ ASSERTIONì„ ì‚¬ìš©í•´ì„œ ëª…ì‹œí•  ìˆ˜ ìˆì§€ë§Œ, í…ŒìŠ¤íŠ¸ ë¹„ìš©ì´ ë§¤ìš° í¬ë©°, í˜„ì¬ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” ë°ì´í„°ë² ì´ìŠ¤ ì‹œìŠ¤í…œë“¤ì—ì„œëŠ” ì§€ì›ë˜ì§€ ì•ŠëŠ”ë‹¤!
- dependency preserving ë¶„í•´ë¥¼ í–ˆë”ë¼ë„,
SQLì—ì„œëŠ” ì¢Œë³€ì´ í‚¤ê°€ ì•„ë‹Œ í•¨ìˆ˜ì  ì¢…ì†ì„±ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê²€ì‚¬í•  ìˆ˜ ì—†ë‹¤. <br>
ë”°ë¼ì„œ BCNFë¡œ ìª¼ê°œëŠ”ê²Œ ë” ì¢‹ë‹¤.

----------------------------------------------------------------------------------------------------------------------------------------------------------

# 7. Storage and File Structures
## ë¬¼ë¦¬ì  ì €ì¥ ë§¤ì²´
- Cache: ê°€ì¥ ë¹ ë¥´ê³  ê°€ì¥ ë¹„ì‹¼ í˜•íƒœì˜ storage
  - íœ˜ë°œì„±, HWê°€ ê´€ë¦¬, ì ‘ê·¼ ì‹œê°„: a few nanoseconds ( $10^{-9}$ seconds)
- Main memory (RAM)
  - íœ˜ë°œì„±, ì ‘ê·¼ ì‹œê°„: a few hundreds nanoseconds ( $10^{-7}$ seconds)
- Flash memory
  â€“ ë¹„íœ˜ë°œì„±, ì ‘ê·¼ ì‹œê°„: under a hundred microseconds ( $10^{-4}$ ~ $10^{-5}$ seconds)
- Magnetic-disk
  - ë¹„íœ˜ë°œì„±, ì ‘ê·¼ì‹œê°„: a few milliseconds ( $10^{-3}$ seconds)
  - ë°ì´í„°ë¥¼ ì ‘ê·¼í•˜ë ¤ë©´ ë””ìŠ¤í¬ì—ì„œ ë©”ì¸ ë©”ëª¨ë¦¬ë¡œ ì˜®ê²¨ì•¼ í•˜ë©°, ì €ì¥í•˜ë ¤ë©´ ë‹¤ì‹œ ë””ìŠ¤í¬ì— ì¨ì•¼ í•œë‹¤.

## File Organization
- The database -> ê° filesë“¤ì˜ ëª¨ìŒ / ê° file -> recordsë“¤ì˜ ìˆœì„œë¡œ êµ¬ì„± / record -> fieldsë“¤ì˜ ìˆœì„œë¡œ êµ¬ì„±
  - ê° fileì€ fixed-length storage unitsì¸ blocksìœ¼ë¡œ ë¶„í•  (blockì€ ì €ì¥ í• ë‹¹ê³¼ ë°ì´í„° ì „ì†¡ì˜ ë‹¨ìœ„ì´ê³ , í•˜ë‚˜ì˜ blockì— ì—¬ëŸ¬ record ê°€ëŠ¥)
- Each fileì€ í•œ ê°€ì§€ ìœ í˜•ì˜ recordsë§Œ í¬í•¨í•˜ê³ , ë‹¤ë¥¸ relationsëŠ” ë‹¤ë¥¸ filesì— ì €ì¥ëœë‹¤.
- records 2ê°€ì§€ ìœ í˜•
  - Fixed-length records(ê³ ì • ê¸¸ì´ ë ˆì½”ë“œ)
  - Variable-length records(ê°€ë³€ ê¸¸ì´ ë ˆì½”ë“œ)
   
## External-Memory Model
- EM Modelì€ RAM (main memory) modelê³¼ ë‹¤ë¥´ë‹¤.
  - Time Complexity in RAM model: O(#basic operations) (e.g., memory access)
  - I/O Complexity in EM model: I/O: O(#I/Oâ€™s (read and write)) <br>
 Linear I/O: O( $N \over B$ ) < O(N)
- ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” í‘œê¸°
  - N: data fileì— ìˆëŠ” recordì˜ ìˆ˜
  - M: main memoryì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” recordì˜ ìˆ˜
  - B: í•˜ë‚˜ì˜ blockì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” recordì˜ ìˆ˜

## Fixed-Length Records
 ID            char(5),       -> 5 bytes <br>
 name          varchar(20),   -> 20 bytes at most <br>
 dept_name     varchar(20),   -> 20 bytes at most <br>
 salary        numeric(8,2),  -> 8 bytes <br>
ì´ 53byte fixed lengthì´ë‹¤.
- Simple approach:
  - ê° record iëŠ” byte n * (iâ€“ 1)ìœ„ì¹˜ ë¶€í„° ì €ì¥í•˜ê¸° ì‹œì‘í•œë‹¤. (nì€ recordì˜ í¬ê¸°ì´ë‹¤)
  - Record ì ‘ê·¼ì€ ê°„ë‹¨í•˜ì§€ë§Œ, recordsê°€ block boundariesë„˜ì§€ ì•Šê²Œ ê°€ì •ì„ í•´ì•¼í•œë‹¤.
- record i ì‚­ì œ:
  - (ë‹¨ìˆœí•œ ë°©ë²•): i+1 ë¶€í„° nê¹Œì§€ ëª¨ë“  ë ˆì½”ë“œë¥¼ ië¶€í„° n-1ê¹Œì§€ ì•ìœ¼ë¡œ ì´ë™í•œë‹¤. <br>
  ë°‘ì—ê±° ë¶€í„° ì±„ìš°ê³ , ì±„ì›Œì§€ë©´ ì œìë¦¬ë¡œê°„ë‹¤. ì´ëŸ°ì‹ìœ¼ë¡œ ì „ë¶€ ì§„í–‰í•˜ë©´ì„œ ì±„ìš´ë‹¤. -> O( $N \over B$ )I/O
  - (ê°œì„  ë°©ë²•): record nì„ ië¡œ ì´ë™ì‹œí‚¨ í›„ ì‚­ì œí•œë‹¤. <br>

![image](https://github.com/user-attachments/assets/6c2b322a-df9f-4093-8feb-502f308053b2)

## Maintaining Free Lists(ì‚­ì œì‹œ ì±„ìš°ê¸°ë³´ë‹¤ëŠ” ê·¸ëƒ¥ ë¹„ì›Œë‘ëŠ” ë°©ë²•)
- file headerì— ì²« ë²ˆì§¸ë¡œ ì‚­ì œëœ recordì˜ ì£¼ì†Œë¥¼ ì €ì¥í•œë‹¤.
- ì´ first recordì— second deleted recordì˜ ì£¼ì†Œë¥¼ ì €ì¥, ì´ëŸ°ì‹ìœ¼ë¡œ ê³„ì† ì—°ê²°í•œë‹¤.
- ì´ëŸ¬í•œ stored addressesë¥¼ pointersë¡œ ìƒê°í•  ìˆ˜ ìˆëŠ”ë°, ì´ëŠ” recordì˜ ìœ„ì¹˜ë¥¼ ê°€ë¦¬í‚¤ê¸° ë•Œë¬¸ì´ë‹¤<br>
![image](https://github.com/user-attachments/assets/d9807fd0-8488-4780-bd98-ed3acdea0089) 
![image](https://github.com/user-attachments/assets/c8916881-42bd-45a8-9fa3-d9a7674b6db6)

## Variable-Length Records
- Variable-length recordsë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°:
  - í•˜ë‚˜ì˜ fileì— multiple record typesì„ ì €ì¥í•˜ëŠ” ê²½ìš°
  - one or more fields(ì˜ˆ: ë¬¸ìì—´ varchar)ì˜ ê¸¸ì´ê°€ variable lengthsì¸ Record types
  - repeating fields(ë°°ì—´ì´ë‚˜ ë©€í‹°ì…‹)ë¥¼ í—ˆìš©í•˜ëŠ” Record types <br>
- ê°€ë³€ ê¸¸ì´ ë ˆì½”ë“œë¥¼ í‘œí˜„í•˜ëŠ” ë°©ë²•
  - Two parts: fixed length attributesì´ ìˆëŠ” initial partê³¼ variable length attributesë¶€ë¶„ì—ëŠ” ë°ì´í„°ê°€ ìˆë‹¤.
  - variable length attributeëŠ” (offset, length)ë¡œ ê³ ì • í¬ê¸° ì˜ì—­ì— ë©”íƒ€ë°ì´í„°ë¥¼ ì €ì¥í•˜ê³ , ì‹¤ì œ ê°’ì€ ë ˆì½”ë“œ ë’¤ìª½ì— ë”°ë¡œ ì €ì¥í•œë‹¤
  - Null ê°’ì€ null-value ë¹„íŠ¸ë§µìœ¼ë¡œ í‘œí˜„ëœë‹¤ <br>

![image](https://github.com/user-attachments/assets/d5ddf809-8058-4b32-b70d-432e3c59c031)

## Variable-Length Records: Slotted Page Structure
- ì—¬ëŸ¬ ê°œì˜ variable-length recordsë¥¼ í•˜ë‚˜ì˜ ë¸”ë¡ì— ì €ì¥í•˜ëŠ” ë°©ë²•:
- slotted page headerì—ëŠ” ë‹¤ìŒ ì •ë³´ê°€ í¬í•¨ë¨:
  - ë ˆì½”ë“œ í•­ëª©ì˜ ê°œìˆ˜
  - ë¸”ë¡ ë‚´ì˜ ë‚¨ì€ ê³µê°„(free space)ì˜ ë ìœ„ì¹˜
  - ê° ë ˆì½”ë“œì˜ ìœ„ì¹˜ì™€ í¬ê¸°
- RecordsëŠ” í˜ì´ì§€ ë‚´ì—ì„œ ì—°ì†ë˜ë„ë¡ ë¹ˆ ê³µê°„ ì—†ì´ ì´ë™ì‹œí‚¬ ìˆ˜ ìˆìœ¼ë©°, ì´ë•Œ entry in the headerê°€ ì—…ë°ì´íŠ¸ë˜ì–´ì•¼ í•œë‹¤.
- PointersëŠ” recordë¥¼ ì§ì ‘ ê°€ë¦¬í‚¤ì§€ ì•Šê³ , ëŒ€ì‹  headerì— ìˆëŠ” í•´ë‹¹ ë ˆì½”ë“œì˜ í•­ëª©(entry)ì„ ê°€ë¦¬ì¼œì•¼ í•œë‹¤. <br>

![image](https://github.com/user-attachments/assets/9ba949e8-9492-4b6f-a66f-8c0aa3b356e3)

## Organization of Records in Files
- íŒŒì¼ì— set of recordsë¥¼ ë°°ì¹˜í•˜ëŠ” ë°©ë²•:
- í™(Heap): ë ˆì½”ë“œëŠ” íŒŒì¼ ë‚´ì˜ ë¹ˆ ê³µê°„ ì–´ë””ë“ ì§€ ì €ì¥ë  ìˆ˜ ìˆë‹¤. -> ì œì¼ ë§ì´ ì“´ë‹¤. ê³µê°„ìˆê³ , ì •ì±…X, fileë„ heap fileì¡´ì¬, record ë„£ì„ë•Œ ë¹„ì›Œìˆìœ¼ë©´ ë„£ëŠ”ë‹¤.
- ìˆœì°¨(Sequential): ê° ë ˆì½”ë“œì˜ search key ê°’ì— ë”°ë¼ ìˆœì°¨ì ìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ì €ì¥í•œë‹¤. -> ì´ì–´ ë¶™ì´ê¸° + ì •ë ¬(pkê°€ ê¸°ì¤€)
- í•´ì‹±(Hashing): ë ˆì½”ë“œì˜ íŠ¹ì • ì†ì„±ì— ëŒ€í•´ í•´ì‹œ í•¨ìˆ˜ë¥¼ ê³„ì‚°í•˜ê³ , ê·¸ ê²°ê³¼ì— ë”°ë¼ ë ˆì½”ë“œë¥¼ ì €ì¥í•  ë¸”ë¡ì´ ê²°ì •ëœë‹¤. -> ì •ë ¬O -> binarysearchë¡œ ì¢€ë” ë¹ ë¥´ê²Œ

## Sequential File Organization
- ì „ì²´ íŒŒì¼ì„ ìˆœì°¨ì (sequential)ìœ¼ë¡œ ì²˜ë¦¬í•´ì•¼ í•˜ëŠ” ì‘ìš© í”„ë¡œê·¸ë¨ì— ì í•©í•˜ë‹¤
- The records in the fileì€ search-keyì— ë”°ë¼ ì •ë ¬ë˜ì–´ ìˆë‹¤ <br>

![image](https://github.com/user-attachments/assets/5f839dc9-7fdc-4cba-ac9c-97d438ad033c) <br>
- Deletion: í¬ì¸í„° ì²´ì¸(pointer chain)ì„ ì‚¬ìš©í•˜ì—¬ ì²˜ë¦¬í•œë‹¤.
- Insertion: ë ˆì½”ë“œë¥¼ ì‚½ì…í•  ìœ„ì¹˜ë¥¼ ì°¾ëŠ”ë‹¤.
  - ë¹ˆ ê³µê°„ì´ ìˆë‹¤ë©´ ê·¸ ìë¦¬ì— ì‚½ì…
  - ë¹ˆ ê³µê°„ì´ ì—†ë‹¤ë©´ ì˜¤ë²„í”Œë¡œìš° ë¸”ë¡(overflow block)ì— ì‚½ì…
  - ì–´ë–¤ ê²½ìš°ë“  í¬ì¸í„° ì²´ì¸(pointer chain)ì„ ì—…ë°ì´íŠ¸í•´ì•¼ í•œë‹¤
- sequential orderë¥¼ restoreí•˜ê¸° ìœ„í•´ fileì„ ì£¼ê¸°ì ìœ¼ë¡œ ì¬êµ¬ì„±(reorganize)í•´ì•¼ í•œë‹¤.

## Storage Access
- database fileì€ blockì´ë¼ ë¶ˆë¦¬ëŠ” fixed-length storage unitsë¡œ ë¶„í• (partitioned)ëœë‹¤.<br>
  blockì€ ì €ì¥ í• ë‹¹(storage allocation)ê³¼ ë°ì´í„° ì „ì†¡(data transfer)ì˜ ë‹¨ìœ„(units)ì´ë‹¤.
- ë°ì´í„°ë² ì´ìŠ¤ ì‹œìŠ¤í…œì€ diskì™€ memory ê°„ì˜ block ì „ì†¡ ìˆ˜ë¥¼ ìµœì†Œí™”í•˜ë ¤ê³  í•œë‹¤.<br>
  ë””ìŠ¤í¬ ì ‘ê·¼ íšŸìˆ˜(the number of disk accesses)ë¥¼ ì¤„ì´ê¸° ìœ„í•´, ê°€ëŠ¥í•œ ë§ì€ ë¸”ë¡ì„ main memoryì— ìœ ì§€í•œë‹¤.
- Buffer: disk blocksì˜ ë³µì‚¬ë³¸ì„ ì €ì¥í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” main memoryì˜ ì¼ë¶€ ê³µê°„ì´ë‹¤.
- Buffer manager: main memory ë‚´ì—ì„œ ë²„í¼ ê³µê°„ì„ í• ë‹¹í•˜ëŠ” ì—­í• ì„ í•˜ëŠ” í•˜ìœ„ ì‹œìŠ¤í…œ(subsystem)ì´ë‹¤.

## Buffer Manager
- programì´ diskì—ì„œ blockì´ í•„ìš”í•  ë•Œ buffer managerë¥¼ í˜¸ì¶œí•œë‹¤.
1. ë¸”ë¡ì´ ì´ë¯¸ ë²„í¼ì— ì¡´ì¬í•˜ë©´, ë²„í¼ ê´€ë¦¬ìëŠ” returns the address of the block in main memory.
2. ë¸”ë¡ì´ ë²„í¼ì— ì—†ìœ¼ë©´, ë²„í¼ ê´€ë¦¬ìëŠ” ë‹¤ìŒì„ ìˆ˜í–‰í•œë‹¤:
   1. í•´ë‹¹ ë¸”ë¡ì„ ìœ„í•œ ë²„í¼ ê³µê°„ì„ í• ë‹¹í•œë‹¤
      1. ê³µê°„ì´ ë¶€ì¡±í•  ê²½ìš°, ë‹¤ë¥¸ ë¸”ë¡ì„ êµì²´(ë²„ë¦¼)í•˜ì—¬ ìƒˆ ë¸”ë¡ì´ ë“¤ì–´ê°ˆ ìë¦¬ë¥¼ ë§Œë“ ë‹¤.
      2. êµì²´ë˜ëŠ” ë¸”ë¡ì€ ìˆ˜ì •ëœ ê²½ìš°ì—ë§Œ ë””ìŠ¤í¬ì— ë‹¤ì‹œ ê¸°ë¡ëœë‹¤ (ê°€ì¥ ìµœê·¼ì˜ ì½ê¸°/ì“°ê¸° ì´í›„ ë³€ê²½ë˜ì—ˆì„ ë•Œë§Œ).
   2. ë””ìŠ¤í¬ì—ì„œ ë¸”ë¡ì„ ì½ì–´ì™€ ë²„í¼ì— ì €ì¥í•œ í›„, ìš”ì²­ì(requester)ì—ê²Œ returns the address of the block in main memory.

## Buffer-Replacement Policies
- ëŒ€ë¶€ë¶„ì˜ OSëŠ” Least Recently Used(LRU)ì„ êµì²´í•˜ëŠ” ì „ëµì„ ì‚¬ìš©í•œë‹¤.
- LRUì˜ ê¸°ë³¸ ì•„ì´ë””ì–´: ê³¼ê±°ì˜ ë¸”ë¡ ì°¸ì¡° íŒ¨í„´ì„ ë¯¸ë˜ì˜ ì°¸ì¡° íŒ¨í„´ì— ëŒ€í•œ ì˜ˆì¸¡ìœ¼ë¡œ í™œìš©í•œë‹¤.
- ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ëŠ” ëª…í™•í•œ ì ‘ê·¼ íŒ¨í„´(access patterns)(such as sequential scans)ì„ ê°€ì§€ë¯€ë¡œ, DBMSëŠ” ì¿¼ë¦¬ ì •ë³´ë¥¼ ì´ìš©í•´ ë¯¸ë˜ì˜ ì°¸ì¡°ë¥¼ ì˜ˆì¸¡í•  ìˆ˜ ìˆë‹¤.
  - LRUëŠ” ë°ì´í„°ë¥¼ ë°˜ë³µì ìœ¼ë¡œ ìŠ¤ìº”í•˜ëŠ” íŠ¹ì • ì ‘ê·¼ íŒ¨í„´ì—ì„œëŠ” ë¹„íš¨ìœ¨ì ì¼ ìˆ˜ ìˆë‹¤. -> ë‘ ë¦´ë ˆì´ì…˜ ì¤‘ì²© ì¡°ì¸
  - ë”°ë¼ì„œ query optimizerê°€ êµì²´ ì „ëµì— ëŒ€í•œ íŒíŠ¸ë¥¼ ì œê³µí•˜ëŠ” mixed strategyê°€ ë” ë°”ëŒì§í•˜ë‹¤.
- ìµœì‹  ì‚¬ìš©(MRU: Most Recently Used) ì „ëµ
  - ì‹œìŠ¤í…œì€ í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ ë¸”ë¡ì„ pin í•œë‹¤.<br>
  í•´ë‹¹ ë¸”ë¡ì˜ ë§ˆì§€ë§‰ íŠœí”Œê¹Œì§€ ì²˜ë¦¬í•˜ë©´ ë¸”ë¡ì˜ unpinnedë˜ê³ , ì´ ë¸”ë¡ì€ ê°€ì¥ ìµœê·¼ì— ì‚¬ìš©ëœ ë¸”ë¡(most recently used block)ì´ ëœë‹¤.
    - pinned block: ë””ìŠ¤í¬ë¡œ ë‹¤ì‹œ ì“°ì—¬ì„œëŠ” ì•ˆ ë˜ëŠ” ë©”ëª¨ë¦¬ ë¸”ë¡ì´ë‹¤.
- Buffer managerëŠ” particular relationì´ ì°¸ì¡°ë  í™•ë¥ ì— ê´€í•œ í†µê³„ ì •ë³´ë¥¼ í™œìš©í•  ìˆ˜ ìˆë‹¤.
  - ì˜ˆ: ë°ì´í„° ì‚¬ì „(data dictionary)ì€ ìì£¼ ì ‘ê·¼ëœë‹¤. Heuristic: data dictionary blocksì€ main memory bufferì— ìœ ì§€í•œë‹¤. 
