# Relational DB Design
## F+ 계산절차
```
 F⁺ = F
 repeat
   for each functional dependency f in F⁺
     apply reflexivity and augmentation rules on f
     add the resulting functional dependencies to F⁺
   for each pair of functional dependencies f1 and f2 in F⁺
     if f1 and f2 can be combined using transitivity
       then add the resulting functional dependency to F⁺
 until F + does not change any further
```
reflexivity(반사성)와 augmentation(증강)을 f에 적용해 더 많은 functional dependencies를 적용하고 나온 결과를 $F^+$에 추가한다.<br>
$F^+$안에 있는 두 쌍에 대해 transitivity가 가능한지 확인하고 가능하면 결과를 $F^+$에 추가한다.<br>
최악의 경우 O($2^n$) 의 F개수 만큼
- Reflexivity: A → A (자기 자신을 함수로)  /  Augmentation: 양쪽에 같은 속성 추가 A → B이면 AC → BC

## Closure of Functional Dependencies
- α → β이고, α → γ라면, α → βγ도 성립한다 (union)
- α → βγ가 성립하면, α → β도 성립하고 α → γ도 성립한다 (decomposition)
- α → β이고, γβ → δ라면, αγ → δ도 성립한다 (pseudotransitivity)

## Closure of Attribute Sets
- set of attributes(속성 집합) α가 주어졌을 때, F에 대한 closure of α(α⁺)를, F에 의해 α로부터 함수적으로 결정되는 속성들의 집합으로 정의한다.
``` 
result := α;
 while (changes to result) do
 for each β → γ in F do
 begin
 if β ⊆ result then result := result ∪ γ
end
```
α → result 이고 β → γ 일때 if부분 만족시 result → β 이므로 α → γ 이다.

### Example of Attribute Set Closure
- R = (A, B, C, G, H, I)  /  F = {A → B, A → C, CG → H, CG → I, B → H}
- $(AG)^+$ 주어진 함수적 종속성 집합 F 아래에서 (AG)⁺를 계산한 결과:
1. result = AG
2. A → B, A → C 사용 → result = ABCG
3. CG → H 사용 가능 (CG ⊆ ABCG) → result = ABCGH
4. CG → I 사용 가능 (CG ⊆ ABCGH) → result = ABCGHI <br>
최종적으로 (AG)⁺ = {A, B, C, G, H, I} AG에서 모든것으로 갈 수 있으므로 superkey이다.
- AG는 cadidate key인가?
  - $A^+$에 대해
  1. result = $A^+$
  2. result = ABC
  3. result = ABCH -> A는 keyX
  - $G^+$에 대해
  1. result = G -> G도 keyX <br>
따라서 $AG^+$는 cadidate key이다.

## Uses of Attribute Closure
there are several uses of the attribute closure algorithm:
- Testing for Superkey:<br>
  α가 슈퍼키인지 확인하려면, α⁺를 계산하고 R(릴레이션의 모든 속성)을 포함하는지 확인한다.
- Testing Functional Dependencies:<br>
  함수적 종속성 α → β가 성립하는지(F⁺에 포함되는지) 확인하려면, α⁺를 구해서 β가 그 안에 포함되는지 확인하면 된다. 
- Computing Closure of F (F⁺ 구하기) :<br>
  $F^+$를 다 구해서 Union을 통해 구할 수 있다.

## Lossless-join Decomposition
- R = (R₁, R₂)로 쪼갠 후,  각각 쪼갠것을 join하면 R로 원상복구 가능
- R을 R₁과 R₂로 decomposition한 것이 lossless join이 되려면, 다음 종속성들 중 적어도 하나가 F⁺에 포함되어 있어야 한다:
  - R₁ ∩ R₂ → R₁
  - R₁ ∩ R₂ → R₂ <br>

따라서, R₁과 R₂의 교집합이 R₁ 또는 R₂ 중 적어도 하나의 슈퍼키(superkey)를 이루면, R의 decomposition는 lossless decomposition이다.
- 참고사항 : <br>
  R = (A,B,C) -> attribute 집합 / r(A,B,C) -> relation

### Example
- R = (A, B, C) <br>
F = {A → B, B → C) A가 key이다. <br>

2가지 다른 방법으로 쪼갤 수 있다.
1. R1 = (A, B),   R2 = (B, C)
- Lossless-join decomposition : R1 ∩ R2 = {B} and B → BC 이므로 R1 ∩ R2 = R2(={BC})이다. <br>
따라서 Dependency preserving
2. R1 = (A, B),   R2 = (A, C)
- Lossless-join decomposition : R1 ∩ R2 = {A} and A → AB R1 ∩ R2 = R1(={AB})이다. <br>
하지만 Not dependency preserving B -> C를 바로 확인 불가능하기 때문

## Dependency Preservation
Fᵢ는 F⁺중에서 Rᵢ에 포함된 attributes만 사용하는 set of dependencies이다.
- 다음 조건이 만족되면 그 분해는 함수적 종속성 보존(dependency preserving)이라 한다: <br>
(F₁ ∪ F₂ ∪ … ∪ Fₙ)⁺ = F⁺
- 이 조건이 만족되지 않으면, 함수적 종속성 위반 여부를 검사하려면 relation들을 join해야 하며, 이는 비용이 많이 든다.

### Example
- R = (A, B, C),  F = {A → B, B →C} -> Key = {A} <br>
R is not in BCNF : B는 후보 키가 아닌데 결정자여서 -> BCNF 위반
- Decomposition R1 = (A, B),  R2 = (B, C) <br>
R1 and R2 in BCNF <br>
Lossless-join decomposition: 분해한 $R_1$과 $𝑅_2$ 를 다시 결합해도 원래의 𝑅을 완전히 복원할 수 있다.<br>
Dependency preserving: 원래 릴레이션에서의 모든 함수 종속성을 분해 후에도 각각의 분해 릴레이션에서 그대로 표현할 수 있다.

## BCNF and Dependency Preservation
항상 BCNF decomposition가 Dependency Preservation을 만족하는 것은 아니다.
- R = (J, K, L) / F = {JK → L, L → K}  candidate key는 JK와 JL 두 개 <br>
R은 BCNF를 만족하지 않는다 <br>
- 이유 : L → K는 BCNF 위반 (L은 슈퍼키가 아님, non trivaial) <br>
단, k는 cadidate key의 일부이므로 3NF 가능 -> 따라서 decompose할 필요가 없다.

## Comparison of BCNF and 3NF
- 3NF의 경우:
  - 항상 어떤 릴레이션이든 3NF로 분해할 수 있다.
  - decomposition lossless가 가능하고
  - 모든 dependencies preserved 할 수 있다.
- BCNF의 경우:
  - 모든 릴레이션을 BCNF로 분해하는 것은 가능하지만
  - decomposition lossless는 가능해도
  - preserve dependencies가 항상 가능한 것은 아니다

## Design Goals
- Goal for a relational database design is:
  - BCNF  /  Lossless join  /  Dependency preservation
- If we cannot achieve this, we accept one of(하나만 선택)
  - Lack of dependency preservation
  - Redundancy due to use of 3NF
-SQL은 슈퍼키(superkey) 이외의 다른 함수적 종속성을 직접적으로 명시하는 방법을 제공하지 않는다.<br>
함수적 종속성(FD)은 ASSERTION을 사용해서 명시할 수 있지만, 테스트 비용이 매우 크며, 현재 널리 사용되는 데이터베이스 시스템들에서는 지원되지 않는다!
- dependency preserving 분해를 했더라도,
SQL에서는 좌변이 키가 아닌 함수적 종속성을 효율적으로 검사할 수 없다. <br>
따라서 BCNF로 쪼개는게 더 좋다.

----------------------------------------------------------------------------------------------------------------------------------------------------------

# 7. Storage and File Structures
## 물리적 저장 매체
- Cache: 가장 빠르고 가장 비싼 형태의 storage
  - 휘발성, HW가 관리, 접근 시간: a few nanoseconds ( $10^{-9}$ seconds)
- Main memory (RAM)
  - 휘발성, 접근 시간: a few hundreds nanoseconds ( $10^{-7}$ seconds)
- Flash memory
  – 비휘발성, 접근 시간: under a hundred microseconds ( $10^{-4}$ ~ $10^{-5}$ seconds)
- Magnetic-disk
  - 비휘발성, 접근시간: a few milliseconds ( $10^{-3}$ seconds)
  - 데이터를 접근하려면 디스크에서 메인 메모리로 옮겨야 하며, 저장하려면 다시 디스크에 써야 한다.

## File Organization
- The database -> 각 files들의 모음 / 각 file -> records들의 순서로 구성 / record -> fields들의 순서로 구성
  - 각 file은 fixed-length storage units인 blocks으로 분할 (block은 저장 할당과 데이터 전송의 단위이고, 하나의 block에 여러 record 가능)
- Each file은 한 가지 유형의 records만 포함하고, 다른 relations는 다른 files에 저장된다.
- records 2가지 유형
  - Fixed-length records(고정 길이 레코드)
  - Variable-length records(가변 길이 레코드)
   
## External-Memory Model
- EM Model은 RAM (main memory) model과 다르다.
  - Time Complexity in RAM model: O(#basic operations) (e.g., memory access)
  - I/O Complexity in EM model: I/O: O(#I/O’s (read and write)) <br>
 Linear I/O: O( $N \over B$ ) < O(N)
- 일반적으로 사용되는 표기
  - N: data file에 있는 record의 수
  - M: main memory에 들어갈 수 있는 record의 수
  - B: 하나의 block에 들어갈 수 있는 record의 수

## Fixed-Length Records
 ID            char(5),       -> 5 bytes <br>
 name          varchar(20),   -> 20 bytes at most <br>
 dept_name     varchar(20),   -> 20 bytes at most <br>
 salary        numeric(8,2),  -> 8 bytes <br>
총 53byte fixed length이다.
- Simple approach:
  - 각 record i는 byte n * (i– 1)위치 부터 저장하기 시작한다. (n은 record의 크기이다)
  - Record 접근은 간단하지만, records가 block boundaries넘지 않게 가정을 해야한다.
- record i 삭제:
  - (단순한 방법): i+1 부터 n까지 모든 레코드를 i부터 n-1까지 앞으로 이동한다. <br>
  밑에거 부터 채우고, 채워지면 제자리로간다. 이런식으로 전부 진행하면서 채운다. -> O( $N \over B$ )I/O
  - (개선 방법): record n을 i로 이동시킨 후 삭제한다. <br>

![image](https://github.com/user-attachments/assets/6c2b322a-df9f-4093-8feb-502f308053b2)

## Maintaining Free Lists(삭제시 채우기보다는 그냥 비워두는 방법)
- file header에 첫 번째로 삭제된 record의 주소를 저장한다.
- 이 first record에 second deleted record의 주소를 저장, 이런식으로 계속 연결한다.
- 이러한 stored addresses를 pointers로 생각할 수 있는데, 이는 record의 위치를 가리키기 때문이다<br>
![image](https://github.com/user-attachments/assets/d9807fd0-8488-4780-bd98-ed3acdea0089) 
![image](https://github.com/user-attachments/assets/c8916881-42bd-45a8-9fa3-d9a7674b6db6)

## Variable-Length Records
- Variable-length records를 사용하는 경우:
  - 하나의 file에 multiple record types을 저장하는 경우
  - one or more fields(예: 문자열 varchar)의 길이가 variable lengths인 Record types
  - repeating fields(배열이나 멀티셋)를 허용하는 Record types <br>
- 가변 길이 레코드를 표현하는 방법
  - Two parts: fixed length attributes이 있는 initial part과 variable length attributes부분에는 데이터가 있다.
  - variable length attribute는 (offset, length)로 고정 크기 영역에 메타데이터를 저장하고, 실제 값은 레코드 뒤쪽에 따로 저장한다
  - Null 값은 null-value 비트맵으로 표현된다 <br>

![image](https://github.com/user-attachments/assets/d5ddf809-8058-4b32-b70d-432e3c59c031)

## Variable-Length Records: Slotted Page Structure
- 여러 개의 variable-length records를 하나의 블록에 저장하는 방법:
- slotted page header에는 다음 정보가 포함됨:
  - 레코드 항목의 개수
  - 블록 내의 남은 공간(free space)의 끝 위치
  - 각 레코드의 위치와 크기
- Records는 페이지 내에서 연속되도록 빈 공간 없이 이동시킬 수 있으며, 이때 entry in the header가 업데이트되어야 한다.
- Pointers는 record를 직접 가리키지 않고, 대신 header에 있는 해당 레코드의 항목(entry)을 가리켜야 한다. <br>

![image](https://github.com/user-attachments/assets/9ba949e8-9492-4b6f-a66f-8c0aa3b356e3)

## Organization of Records in Files
- 파일에 set of records를 배치하는 방법:
- 힙(Heap): 레코드는 파일 내의 빈 공간 어디든지 저장될 수 있다. -> 제일 많이 쓴다. 공간있고, 정책X, file도 heap file존재, record 넣을때 비워있으면 넣는다.
- 순차(Sequential): 각 레코드의 search key 값에 따라 순차적으로 정렬하여 저장한다. -> 이어 붙이기 + 정렬(pk가 기준)
- 해싱(Hashing): 레코드의 특정 속성에 대해 해시 함수를 계산하고, 그 결과에 따라 레코드를 저장할 블록이 결정된다. -> 정렬O -> binarysearch로 좀더 빠르게

## Sequential File Organization
- 전체 파일을 순차적(sequential)으로 처리해야 하는 응용 프로그램에 적합하다
- The records in the file은 search-key에 따라 정렬되어 있다 <br>

![image](https://github.com/user-attachments/assets/5f839dc9-7fdc-4cba-ac9c-97d438ad033c) <br>
- Deletion: 포인터 체인(pointer chain)을 사용하여 처리한다.
- Insertion: 레코드를 삽입할 위치를 찾는다.
  - 빈 공간이 있다면 그 자리에 삽입
  - 빈 공간이 없다면 오버플로우 블록(overflow block)에 삽입
  - 어떤 경우든 포인터 체인(pointer chain)을 업데이트해야 한다
- sequential order를 restore하기 위해 file을 주기적으로 재구성(reorganize)해야 한다.

## Storage Access
- database file은 block이라 불리는 fixed-length storage units로 분할(partitioned)된다.<br>
  block은 저장 할당(storage allocation)과 데이터 전송(data transfer)의 단위(units)이다.
- 데이터베이스 시스템은 disk와 memory 간의 block 전송 수를 최소화하려고 한다.<br>
  디스크 접근 횟수(the number of disk accesses)를 줄이기 위해, 가능한 많은 블록을 main memory에 유지한다.
- Buffer: disk blocks의 복사본을 저장하기 위해 사용되는 main memory의 일부 공간이다.
- Buffer manager: main memory 내에서 버퍼 공간을 할당하는 역할을 하는 하위 시스템(subsystem)이다.

## Buffer Manager
- program이 disk에서 block이 필요할 때 buffer manager를 호출한다.
1. 블록이 이미 버퍼에 존재하면, 버퍼 관리자는 returns the address of the block in main memory.
2. 블록이 버퍼에 없으면, 버퍼 관리자는 다음을 수행한다:
   1. 해당 블록을 위한 버퍼 공간을 할당한다
      1. 공간이 부족할 경우, 다른 블록을 교체(버림)하여 새 블록이 들어갈 자리를 만든다.
      2. 교체되는 블록은 수정된 경우에만 디스크에 다시 기록된다 (가장 최근의 읽기/쓰기 이후 변경되었을 때만).
   2. 디스크에서 블록을 읽어와 버퍼에 저장한 후, 요청자(requester)에게 returns the address of the block in main memory.

## Buffer-Replacement Policies
- 대부분의 OS는 Least Recently Used(LRU)을 교체하는 전략을 사용한다.
- LRU의 기본 아이디어: 과거의 블록 참조 패턴을 미래의 참조 패턴에 대한 예측으로 활용한다.
- 데이터베이스 쿼리는 명확한 접근 패턴(access patterns)(such as sequential scans)을 가지므로, DBMS는 쿼리 정보를 이용해 미래의 참조를 예측할 수 있다.
  - LRU는 데이터를 반복적으로 스캔하는 특정 접근 패턴에서는 비효율적일 수 있다. -> 두 릴레이션 중첩 조인
  - 따라서 query optimizer가 교체 전략에 대한 힌트를 제공하는 mixed strategy가 더 바람직하다.
- 최신 사용(MRU: Most Recently Used) 전략
  - 시스템은 현재 처리 중인 블록을 pin 한다.<br>
  해당 블록의 마지막 튜플까지 처리하면 블록의 unpinned되고, 이 블록은 가장 최근에 사용된 블록(most recently used block)이 된다.
    - pinned block: 디스크로 다시 쓰여서는 안 되는 메모리 블록이다.
- Buffer manager는 particular relation이 참조될 확률에 관한 통계 정보를 활용할 수 있다.
  - 예: 데이터 사전(data dictionary)은 자주 접근된다. Heuristic: data dictionary blocks은 main memory buffer에 유지한다. 
