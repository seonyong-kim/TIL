# Virtual Memory

## Motivation of Virtual Memory
- 코드와 데이터는 실행을 위해 메모리에 있어야 하지만, 전체 프로그램이 모두 사용되는 경우는 적다.
  - 예: 오류 코드, 특이한 루틴, 대형 데이터 구조 등 어떤 코드는 안 다루기도 한다.
- 부분적으로만 적재된 프로그램(partially-loaded program)을 실행할 수 있는 기능을 고려
  - 프로그램이 더 이상 물리적 메모리(physical memory)의 한계에 제약받지 않는다. -> 제약 X
  - 실행 중인 각 프로그램이 차지하는 메모리 공간이 줄어든다. -> 따라서 동시에 더 많은 프로그램 실행 가능하다. degree of multiprograming 증가.
    - 이에 따라 CPU 활용률(CPU utilization)과 처리량(throughput)이 증가하지만, 응답 시간(response time)이나 반환 시간(turnaround time)은 증가하지 않는다.
  - 프로그램을 메모리에 적재하거나 스와핑할 때 필요한 I/O가 줄어든다. -> 각 사용자 프로그램이 더 빨리 실행됨
- 이러한 장점때문에 virtual memory 시작

## Virtual Memory
- 사용자 논리 메모리(user logical memory)와 물리 메모리(physical memory)를 분리한다.
  - 실행을 위해 프로그램의 일부만 메모리에 있으면 된다.
  - 따라서 Logical address space는 physical address space보다 훨씬 클 수 있음
  - 여러 프로세스가 주소 공간(address spaces)을 공유할 수 있다.
    - 더 효율적인 프로세스 생성이 가능하다.
    - 동시에 더 많은 프로그램 실행 가능
    - Less I/O needed to load or swap processes
- 가상 주소 공간(Virtual address space): 프로세스가 메모리에 저장되는 논리적인 관점
  - 보통 주소 0부터 시작하며, 공간의 끝까지 연속적인 주소 사용
  - 반면, 물리 메모리는 page frames 단위로 구성됨
  - MMU(Memory Management Unit)는 논리 주소를 물리 주소로 매핑해야 함
- Virtual memory는 다음 방식으로 구현 가능
  - Demand paging
  - Demand segmentation

## Virtual Memory(2)
- Virtual memory는 physical memory보다 더 크다 <br>

![image](https://github.com/user-attachments/assets/0805e26e-4b0c-4dea-8526-e2e37495d5d7) <br>

- Virtual address space
  - Contiguous memory space 0 to max (code to stack)
  - Unused address space between stack and heap
  - System libraries shared via mapping into virtual address space
  - Shared memory by mapping pages read-write into virtual address space
  - Pages can be shared during fork(), speeding process creation
  - 0부터 최대치까지 연속적인 메모리 공간 (코드부터 스택까지)
  - 스택과 힙 사이에는 사용되지 않는 주소 공간 존재
  - 시스템 라이브러리는 가상 주소 공간에 매핑하여 공유됨
  - 공유 메모리는 페이지를 read-write 권한으로 가상 주소 공간에 매핑함으로써 가능하다.
  - fork() 중에 페이지를 공유함으로써 프로세스 생성 속도를 높일 수 있음 <br>

![image](https://github.com/user-attachments/assets/3c59ae3e-0fde-4d80-997f-f9cb9b568dd0)
- Shared library using virtual memory <br>

![image](https://github.com/user-attachments/assets/aee7af08-6638-44cd-a793-62bc28f7867d)

# Demand Paging
## Basic Concept of Demand Paging
- 페이지를 메모리에 불러오는 것은 필요할 때만 수행
  - 더 적은 I/O 필요, 불필요한 I/O 없다
  - 더 적은 메모리 필요
  - 더 빠른 응답 속도
  - 더 많은 사용자 가능
- 스와핑(swapping)이 있는 페이징 시스템(paging system)과 유사
- 페이지가 필요할 경우 → 해당 페이지에 대한 참조 발생
  - 잘못된 참조(참조를 해도 되는 부분을 참조하는지 확인) → 중단
  - 메모리에 없음 → 메모리로 불러옴
- Lazy swapper: 페이지가 필요할 때만 메모리에 스와핑
  - 페이지를 다루는 swapper는 pager라고 함<br>
 
![image](https://github.com/user-attachments/assets/63bc860c-5262-491b-9ea5-50c15bede2f0) <br>
- demand paging을 구현하려면 새로운 MMU 기능이 필요하다 -> 추가적으로 주소변환 + memory에 있는지 check
- 필요한 페이지가 이미 메모리에 상주해 있다면
  - non demand-paging 경우와 차이 없다
- 필요한 페이지가 메모리에 없을 경우
  - 페이지가 필요한 것을 감지하고 저장장치(storage)에서 메모리로 로드해야 한다. -> storage어디에 있는지 check
    - 프로그램 동작을 변경하지 않고
    - 프로그래머가 코드를 변경할 필요 없이

## Valid-Invalid Bit -> memory에 있는지 check
- With each page table entry a valid-invalid bit is associated
  - v -> in memory (memory resident)
  - i -> not-in-memory
- Initially valid-invalid bit is set to i on all entries
- Example of a page table snapshot: <br>

각 페이지 테이블 항목에는 유효-무효 비트(valid-invalid bit)가 연결되어 있음

v → 메모리에 있음 (memory resident)

i → 메모리에 없음

초기에는 모든 항목의 유효-무효 비트를 i로 설정함

페이지 테이블 스냅샷 예시:

![image](https://github.com/user-attachments/assets/e8e2d393-cf88-492f-ba67-f42fec4717d2)<br>
- During MMU address translation, if valid-invalid bit is i -> page fault

