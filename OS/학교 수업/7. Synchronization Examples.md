# 7. Synchronization Examples
## Classical Problems of Synchronization
- 새롭게 제안된 동기화(synchronization) 기법을 테스트하는 데 사용되는 고전적인 문제들 3가지
  - Bounded-Buffer Problem
  - Readers and Writers Problem
  - Dining-Philosophers Problem
 
## Bounded-Buffer Problem (1)
- 6장의 consumer-producer problem으로 돌아가보면<br>
![image](https://github.com/user-attachments/assets/a71e4ed3-9e61-47ab-a34a-88acdbc03963)

## Bounded-Buffer Problem (2)
- n개의 buffers, 각각은 item 1개씩 가질 수 있다.
  - Buffer size = n
- Semaphore mutex initialized to the value 1 // buffer접근에 대한 mutual exclusion보장
- Semaphore full initialized to the value 0 // n개중에 몇개가 사용되고 있는지
- Semaphore empty initialized to the value n // n개중에 비어있는 buffer의 수
### The structure of the producer process
![image](https://github.com/user-attachments/assets/bb419bdf-1fbc-4c0a-b4ea-fed2bf7df3fb)

### The structure of the consumer process
![image](https://github.com/user-attachments/assets/3257135b-1919-4496-ad86-f3ee4b565698)

## Readers-Writers Problem
- 하나의 data set이 여러 개의 동시 수행 process들 사이에서 공유된다. process는 아래 2가지중에 하
  - Readers: 데이터 집합을 읽기만 함; 수정은 하지 않는다.
  - Writers: 읽기와 쓰기 모두 가능한다.
- Problem : 여러 Reader가 동시에 읽을 수 있도록 허용
  - 단, 하나의 Writer만이 동시에 공유 데이터를 접근할 수 있어야 함
- Reader와 Writer를 고려하는 방식에는 여러 변형이 있으며, 모두 일종의 우선순위를 포함함
- Shared data
  - Data set
  - Semaphore rw_mutex (초기값: 1) -> 하나의 writer만 접근하도록 하는 mutex
  - Semaphore mutex (초기값: 1) -> read-count 접근 통제용 mutex
  - Integer read_count (초기값: 0) -> 몇명의 reader가 들어와 있는지 확인용
### The structure of a writer process
![image](https://github.com/user-attachments/assets/cde1550f-4ba1-44e3-b78f-1e3bfead85a1)
### The structure of a reader process(reader 우선권)
![image](https://github.com/user-attachments/assets/9fdeaa61-7bf6-42b1-8ed3-f958e6bd9c8f)

## Readers-Writers Problem Variations
- 첫번째 변형 (Reader 우선): Writer가 공유 객체를 사용할 권한을 가진 경우가 아니면, 어떤 Reader도 기다리지 않는다.
- 두번째 변형 (Writer 우선): 하나의 Writer가 준비되면, 가능한 한 빨리 쓰기를 수행한다.
- 두 방식 모두 starvation현상이 발생할 수 있으며, 이로 인해 더 많은 변형들이 생겨난다.
- 이 문제는 일부 시스템에서는 kernel이 reader-writer locks을 제공함으로써 해결된다.

## Readers-Writers Problem(Writer우선)
- semaphore rw_mutex = 1; // 위와 동일
- semaphore mutex = 1; // 위와 동일
- int read_count = 0;
- semaphore queue = 1;  // writer에게 block당한 reader 대기 큐<br>
### Reader
![image](https://github.com/user-attachments/assets/4b2906e8-d2f3-4895-a7b6-0a1c0e6a2d13)<br>
deadlock인 상황 더 자세히 말해보면 Reader1이 들어와서 읽기 수행중 writer가 들어와 wait(queue)를 지나 wait(rw_mutex)에 멈춰있는 상황이라고 하자(br)
그떄 reader2가 들어오면 wait(mutex)를 지나 wait(queue)에 멈추게 되고, 이후 Reader1이 작업 마친후 wait(mutex)를 하지 못하므로 deadlock에 걸리게 된다.

### Writer
![image](https://github.com/user-attachments/assets/2d480fc3-f813-453a-9275-82f8e3c4a8e3)

------여기서 부터 다시 공부-----
## Dining-Philosophers Problem (1)







