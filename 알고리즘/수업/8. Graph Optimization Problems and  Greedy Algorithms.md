# 8. Graph Optimization Problems and Greedy Algorithms
## Optimization Problems(ê°€ì¥ ìµœì ì˜ í•´ë¥¼ ì°¾ëŠ”ë‹¤)
- Minimizing the total costs or Maximizing the total benefits
  - ê°€ëŠ¥í•œ ëª¨ë“  ê²°ê³¼ì¤‘ ìµœê³ ì˜ ë°©ë²•ì„ ì°¾ëŠ”ë‹¤.
  - Make a series of choices whose overall effect is to achieve the optimal
- optimal í•´ê²° ê¸°ë²•: ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜, DP 2ê°€ì§€ê°€ ìˆë‹¤.

## Greedy Algorithms
- ìˆœì°¨ì ìœ¼ë¡œ ì„ íƒí•˜ê¸°
  - ê°ê°ì˜ ìˆœê°„ì— ìµœê³ ì˜ ì„ íƒí•˜ê¸°
  - ì¼ë‹¨ ì„ íƒì´ ì´ë£¨ì–´ì§€ë©´ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!(ì˜ ëª»ë˜ì–´ë„)
- ê°€ëŠ¥í•œ ë‹¨ì 
  - í˜„ì¬ì˜ ì ì€ costê°€ ë¯¸ë˜ì— ë” í° cost ë°œìƒ ê°€ëŠ¥

## Graph Optimization Problems
- Some optimization problems can be solved exactly by greedy algorithms
- Minimum cost for connecting all vertices
  - Minimum Spanning Tree Algorithm
- Shortest Path between two vertices
  - Single-Source Shortest Paths Algorithm
 
## Minimum Spanning Tree(MST): 2ê°€ì§€ ì•Œê³ ë¦¬ì¦˜ ì¡´ì¬
- A spanning treeëŠ” connected, undirected graphì´ë‹¤.
  - subgraph of GëŠ” undirected treeì´ê³  contains all the vertices of G.
- In a weighted graph G=(V,E,W), the weight of a subgraph is
  - the sum of the weights of the edges in the subgraph.
- A minimum spanning tree for a weighted graph is(weight sumì´ ìµœì†Œ ì¼ë–„)
  - a spanning tree with the minimum weight.<br>
![image](https://github.com/user-attachments/assets/329c2056-7603-4109-a7bd-f4f935aa3fc3) <br>
2,3ë²ˆì¨° ëª¨ë‘ MST -> MSTëŠ” ìœ ì¼í•˜ì§€ ì•Šë‹¤.

## Primâ€™s Algorithm
- ì„ì˜ì˜ ì‹œì‘ vertex ì„ íƒ(the root)
- ì§€ê¸ˆê¹Œì§€ ë§Œë“¤ì–´ì˜¨ ë‚˜ë¬´ì—ì„œ Branchë“¤ì´ ìˆë‹¤.
  - ê° iterationë§ˆë‹¤ edge ì„ íƒí•˜ê¸°
  - treeì— edge ë¶€ì°©í•˜ê¸°
    - ì¸ì ‘í•œ ëª¨ë“  edgeì¤‘ì—ì„œ minimumí•œ weightë¥¼ ê³ ë¥¸ë‹¤. 
  - add to the tree the vertex associated with the edge
- ì•Œê³ ë¦¬ì¦˜ì´ ì§„í–‰ë˜ëŠ” ë™ì•ˆ vertexëŠ” ë‹¤ìŒì˜ 3ê°€ì§€ categoryì¤‘ í•˜ë‚˜ë¡œ ë‚˜ë‰œë‹¤
  - Tree vertices: MSTì— ì†í•˜ëŠ” ê²ƒ
  - Fringe vertices: MSTì—ëŠ” ì—†ì§€ë§Œ Tree vertexì— ì¸ì ‘í•œê²ƒ
  - Unseen vertices: ê·¸ì™¸ ëª¨ë‘
 
## The Algorithm in Action, Example
![image](https://github.com/user-attachments/assets/b20847c4-caa9-493b-b8e3-0ceabc22d826)<br>
ë°‘ì€ ë°˜ë³µë¬¸ì´ ê³„ì†ë˜ë©´ì„œ ì§„í–‰ë˜ëŠ” ê³¼ì •ì´ë‹¤.<br>
![image](https://github.com/user-attachments/assets/df94aaa0-6823-42e4-a755-dbbf13e9a872)<br>
![image](https://github.com/user-attachments/assets/18954f98-3bd1-4580-a35e-2dbc7c5165fe)<br>
![image](https://github.com/user-attachments/assets/9ab592dd-4c38-4008-9f3b-26e0470ef499)

## Primâ€™s Algorithm: Outline
![image](https://github.com/user-attachments/assets/94bb6f13-a924-4f9d-ae09-5a469ba4e178)

## Kruskalâ€™s Algorithm: Outline
O(mlogn)time/ worst: ì…ë ¥í•œ edgeìˆ˜ ë§Œí¼
```
KruskalMST(G,n) // outline
  R= E// R is remaining edges
  F= NULL// F is forest edges
  while (R is not empty)
    Remove the lightest (shortest) edge, vw, from R;
    if (vw does not make a cycle in F)
      Add vw to F;
  return F ;
```
ì§‘í•¨ìˆ˜ = vectexìˆ˜ ì´ë©´ ì•Œê³ ë¦¬ì¦˜ ì¢…ë£Œ
## Data Structure for Kruskalâ€™s Algorithm
- í•˜ë‚˜ì˜ ìë£Œêµ¬ì¡°ë¥¼ ë” ì‚¬ìš©í•œë‹¤.(Union find ADT)
- The algorithm maintains a forest of trees
- ê°ê°ì˜ edgeë¥¼ ìê¸°ìì‹ ë§Œì˜ treeë¡œ í‘œí˜„(ê·¸ë˜ì„œ forestë¼ëŠ” ìš©ì–´ ì‚¬ìš©)
- We need a data structure that maintains a collection of disjoint sets, with the operations:
  - find(u): keyê°’ ìµœì†Œ return
  - union(u,v): ë‘ setì´ ë‹¤ë¥´ë©´ í•©ì¹˜ê³ , ê°™ìœ¼ë©´ ìˆ˜í–‰ì•ˆí•œë‹¤.

## Example
![image](https://github.com/user-attachments/assets/e61e8cbb-7cb3-48c7-9557-eefff2cb92b3)<br>
ì–‘ë ë‘ vertex find ê²°ê³¼ idê°€ ë‹¬ë¼ì„œ unionì‹¤í–‰<br> (ìƒëµ) <br>
![image](https://github.com/user-attachments/assets/a57000a4-b868-4a82-b529-1973ea96f71e)<br>
ì–‘ë ë‘ vertex find ê²°ê³¼ idê°€ ê°™ì´ì„œ unionì‹¤í–‰ì•ˆí•œë‹¤. -> ë‘ vertexê°€ ê°™ì€ treeì— ìˆë‹¤. <br>
![image](https://github.com/user-attachments/assets/30e25555-e703-4b38-b8ac-bec18a952eb0)
<br> (ìƒëµ) <br>
- ê²°ê³¼ <br>
![image](https://github.com/user-attachments/assets/3c7258d6-02b3-4cc6-9cfc-f079a20966c8)

## Problem: Single-Source Shortest Paths
1. single-source shortest paths: nê°œì˜ shortest pathê³„ì‚°(ë³¸ì¸->ë³¸ì¸ í¬í•¨)
2. single destination shortest paths: 1ê³¼ ìœ ì‚¬í•˜ì§€ë§Œ ë°©í–¥ì´ ë°˜ëŒ€ -> 1ì—ì„œ transposeì´ìš©í•´ edgeì˜ ë°©í–¥ë°”ê¿”ì£¼ë©´ í•´ê²°ê°€ëŠ¥ <br>
![image](https://github.com/user-attachments/assets/7104ecf1-0f46-4a63-9007-2bbfd837f2fd)<br>
3. single-pair shortest path: source->destination 1ê°€ì§€ shortest path ê³„ì‚° <br>
1ë¡œ ì§„í–‰í•˜ë‹¤ê°€ destinationë‚˜ì˜¤ë©´ return í•˜ë©´ 3ë²ˆ
4. All-pair shortest path: ëª¨ë“  ì •ì ìŒì— ëŒ€í•œ shortest pathê³„ì‚° <br>
ê°ê°ì˜ vertexë¥¼ ì‹œì‘ ì •ì ìœ¼ë¡œí•´ì„œ ì „ë¶€ 1ë²ˆì„ í•˜ë©´ 4ë²ˆì´ ëœë‹¤.
-  Problem
  - ë‘ ì§€ì •ëœ vertices ê°„ì˜ minimum-weight pathë¥¼ ì°¾ê¸°
  - ìµœì•…ì˜ ê²½ìš°ì—, ì§€ì •ëœ ë‘ ë…¸ë“œ sì™€ t ì‚¬ì´ì˜ ìµœì†Œ ê°€ì¤‘ì¹˜ ê²½ë¡œë¥¼ ì°¾ëŠ” ê²ƒì´(ìœ„ì˜ 3ë²ˆ ìƒí™©), sì—ì„œ ë„ë‹¬ ê°€ëŠ¥í•œ ëª¨ë“  ì •ì ê¹Œì§€ì˜ ìµœì†Œ ê°€ì¤‘ì¹˜ ê²½ë¡œë¥¼ ì°¾ëŠ” ê²ƒ(1ë²ˆ ìƒí™©)ë³´ë‹¤ ì‰½ì§€ ì•ŠìŒ
    - single-source shortest path problem

## Shortest-Path
- Definition: shortest path
  - weighted graph G=(V,E,W)ì—ì„œ kê°œì˜ edges xvâ‚, vâ‚vâ‚‚, ..., v_{k-1}yë¡œ êµ¬ì„±ëœ ê³µë°±ì´ ì•„ë‹Œ path Pê°€ ìˆë‹¤ê³  í•˜ì (vâ‚ = yì¼ ìˆ˜ë„ ìˆìŒ).
  - Pì˜ weight W(P)ëŠ” W(xvâ‚), W(vâ‚vâ‚‚), ..., W(v_{k-1}y)ì˜ í•©ì´ë‹¤.
  - ë§Œì•½ x=yë¼ë©´, ë¹ˆ ê²½ë¡œ(empty path(self loopë¥¼ ë§í•˜ëŠ”ê±° ì•„ë‹˜))ë¥¼ xì—ì„œ yë¡œ ê°€ëŠ” ê²½ë¡œë¡œ ê°„ì£¼í•˜ë©°, ë¹ˆ ê²½ë¡œì˜ ê°€ì¤‘ì¹˜ëŠ” 0ì´ë‹¤.
  - xì™€ y ì‚¬ì´ì˜ ì–´ë–¤ ê²½ë¡œë„ W(P)ë³´ë‹¤ ì‘ì€ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§€ì§€ ì•ŠëŠ”ë‹¤ë©´, Pë¥¼ ìµœë‹¨ ê²½ë¡œ(shortest path(ì—¬ëŸ¬ê°œë„ ê°€ëŠ¥ -> ê·¸ëŸ¼ ì•„ë¬´ê±°ë‚˜)) ë˜ëŠ” ìµœì†Œ ê°€ì¤‘ì¹˜ ê²½ë¡œ(minimum-weight path)ë¼ ë¶€ë¥¸ë‹¤.

## Properties of Shortest Paths
- ë³´ì¡°ì •ë¦¬: Shortest path property
  - weighted graph Gì—ì„œ, xì—ì„œ zê¹Œì§€ì˜ shortest pathê°€ xì—ì„œ yê¹Œì§€ì˜ path Pì™€ yì—ì„œ zê¹Œì§€ì˜ path Që¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤ê³  í•˜ì.
  - ê·¸ëŸ¬ë©´ PëŠ” xì—ì„œ yê¹Œì§€ì˜ shortest pathì´ê³ , QëŠ” yì—ì„œ zê¹Œì§€ì˜ shortest pathì´ë‹¤.<br>
![image](https://github.com/user-attachments/assets/58df7422-9343-484e-abf2-b665002706e7)<br>
ìœ„ëŠ” optimal substructureì´ë‹¤. ë‹¨, ì—­ì€ ì„±ë¦½í•˜ì§€ ì•ŠëŠ”ë‹¤. (shortest pathë¥¼ ìª¼ê° ê±°ëŠ” ëª¨ë‘ shortest path) <br>
- greedy ì ìš©ê°€ëŠ¥ 2ê°€ì§€ ì¡°ê±´
  1. greedy choice property => í•­ìƒì´ìµì´ ë˜ë„ë¡ ì„ íƒ
  2. optimal structure

## Dijkstraâ€™s Shortest-Path Algorithm (primê³¼ ë§¤ìš° ìœ ì‚¬)
- WeightsëŠ” ìŒìˆ˜ê°€ ì•„ë‹ˆì—¬ì•¼ í•œë‹¤.
![image](https://github.com/user-attachments/assets/8256fd4b-51b7-4e1c-83e3-2ab07ac2b68a)
  - Heapì„ ì´ìš©í•˜ë©´ O(mlogn)
  - unsorted sequenceë¥¼ ì´ìš©í•˜ë©´ O($n^{2}$)

## The Algorithm in Action, Example
ì „ì²´ì—ì„œ weight ìŒìˆ˜ ì—†ë‹¤(directed, undirected ëª¨ë‘ ê°€ëŠ¥)<br>
![image](https://github.com/user-attachments/assets/16a64b77-4e20-4746-9732-67b09e41a75c)<br>
ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ë‹¤<br>
![image](https://github.com/user-attachments/assets/c489adbc-d170-480a-95a3-d38d1f657485)

## Correctness
- ì •ë¦¬
  - G=(V,E,W)ëŠ” ìŒìˆ˜ê°€ ì•„ë‹Œ weightë¥¼ ê°€ì§„ weighted graphì´ë‹¤.
  - VëŠ” V'ì˜ ë¶€ë¶„ì§‘í•©ì´ê³ , sëŠ” V'ì˜ ì›ì†Œì´ë‹¤.
  - ê° ğ‘¦âˆˆğ‘‰â€²ì— ëŒ€í•´ d(s,y)ëŠ” sì—ì„œ yê¹Œì§€ G ë‚´ shortest distanceë¼ê³  ê°€ì •í•œë‹¤.
  - ë§Œì•½ y âˆˆ V'ì´ê³  z âˆˆ Vâˆ’V'ì¸ ëª¨ë“  edge yz ì¤‘ì—ì„œ d(s,y) + W(yz)ë¥¼ ìµœì†Œí™”í•˜ëŠ” edge yzë¥¼ ì„ íƒí•œë‹¤ë©´, sì—ì„œ yê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œì™€ ê°„ì„  yzë¡œ ì´ë£¨ì–´ì§„ ê²½ë¡œëŠ” sì—ì„œ zê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œì´ë‹¤.
- ì •ë¦¬
  - ë¹„ìŒìˆ˜ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§„ directed weighted graph Gì™€ source(ì‹œì‘) vertex sê°€ ì£¼ì–´ì¡Œì„ ë•Œ, Dijkstra's algorithmì€ sì—ì„œ ë„ë‹¬ ê°€ëŠ¥í•œ Gì˜ ëª¨ë“  ì •ì ê¹Œì§€ì˜ shortest distanceë¥¼ ê³„ì‚°í•œë‹¤. <br>
![image](https://github.com/user-attachments/assets/58e91d2e-c1eb-4ed3-9d50-6bd7d42473ae)


